<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Fabric Bag Preview</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    #container {
      display: flex;
      width: 100vw;
      height: 100vh;
    }

    /* Left Panel - 2D Fabric Positioning */
    #left-panel {
      width: 30%;
      background: #f5f5f5;
      display: flex;
      flex-direction: column;
      border-right: 2px solid #ccc;
    }

    #controls-header {
      background: white;
      padding: 20px;
      border-bottom: 1px solid #ddd;
    }

    #controls-header h2 {
      margin: 0 0 15px 0;
      font-size: 20px;
      color: #333;
    }

    .panel-section {
      margin-bottom: 20px;
      margin-top: 20px;
    }

    .panel-section h3 {
      margin: 0 0 10px 0;
      font-size: 14px;
      font-weight: 600;
      color: #666;
      text-transform: uppercase;
    }

    .file-input-wrapper {
      display: flex;
      gap: 5 px;
      align-items: center;
      margin-bottom: 10px;
      margin-top: 20px;
    }

    .file-input-wrapper label {
      flex: 1;
      display: block;
      font-size: 16px;
      color: #444;
    }

    .file-input-wrapper input[type="file"] {
      font-size: 16px;
    }

    #panel-toggle-buttons {
      display: flex;
      gap: 10px;
    }

    .toggle-btn {
      flex: 1;
      padding: 10px 15px;
      background: #e9ecef;
      color: #495057;
      border: 2px solid #dee2e6;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .toggle-btn:hover {
      background: #dee2e6;
      border-color: #adb5bd;
    }

    .toggle-btn.active {
      background: #507CBC;
      color: white;
      border-color: #507CBC;
    }

    .library-btn {
      width: 100%;
      padding: 10px 15px;
      margin-top: 10px;
      background: white;
      color: #507CBC;
      border: 2px solid #507CBC;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .library-btn:hover {
      background: #507CBC;
      color: white;
    }

    .library-btn:hover svg {
      stroke: white;
    }

    #generate-btn {
      width: 100%;
      padding: 12px 20px;
      background: #507CBC;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
    }

    #generate-btn:hover {
      background: #218838;
    }

    #generate-btn:active {
      background: #1e7e34;
    }

    #canvas-container {
      flex: 1;
      position: relative;
      overflow: hidden;
      background: white;
    }

    #fabric-canvas {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      border: 1px solid #ddd;
      cursor: grab;
    }

    #fabric-canvas:active {
      cursor: grabbing;
    }

    .canvas-instructions {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 12px;
      pointer-events: none;
    }

    /* Right Panel - 3D Preview */
    #right-panel {
      width: 70%;
      position: relative;
      background: #f0f0f0;
    }

    #c {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* Image Library Sidebar */
    #fabric-menu-side {
      position: fixed;
      right: -350px;
      top: 0;
      width: 350px;
      height: 100vh;
      background: white;
      box-shadow: -2px 0 10px rgba(0,0,0,0.2);
      transition: right 0.3s ease;
      z-index: 1000;
      overflow-y: auto;
    }

    #fabric-menu-side.open {
      right: 0;
    }

    #fabric-toggle {
      position: fixed;
      right: 10px;
      top: 10px;
      width: 50px;
      height: 50px;
      background: #507CBC;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 24px;
      font-weight: bold;
      cursor: pointer;
      z-index: 1001;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      transition: all 0.3s ease;
    }

    #fabric-toggle:hover {
      background: #3d5f99;
      transform: scale(1.05);
    }

    #fabric-toggle.open {
      right: 360px;
    }

    .image-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      padding: 20px;
    }

    .image-item {
      aspect-ratio: 1;
      border: 2px solid #ddd;
      border-radius: 8px;
      overflow: hidden;
      cursor: pointer;
      transition: all 0.2s ease;
      background: #f9f9f9;
    }

    .image-item:hover {
      border-color: #507CBC;
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(80, 124, 188, 0.3);
    }

    .image-item.selected {
      border-color: #507CBC;
      border-width: 3px;
      box-shadow: 0 4px 12px rgba(80, 124, 188, 0.5);
    }

    .image-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
  </style>
</head>
<body>
    <button id="fabric-toggle" type="button" aria-controls="fabric-menu-side" aria-expanded="false" title="Show image library">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="3" y="3" width="7" height="7" />
        <rect x="14" y="3" width="7" height="7" />
        <rect x="3" y="14" width="7" height="7" />
        <rect x="14" y="14" width="7" height="7" />
      </svg>
    </button>

    <div
      id="fabric-menu-side"
      data-bucket="wompatuck-prints"
      data-prefix="prints/"
      data-baseurl="https://wompatuck-prints.s3.us-west-1.amazonaws.com/"
      data-max="1000"
    ></div>
    <script src="sidebar.js"></script>
    <script>
      // Toggle sidebar functionality
      document.addEventListener('DOMContentLoaded', function() {
        const toggleBtn = document.getElementById('fabric-toggle');
        const sidebar = document.getElementById('fabric-menu-side');

        console.log('Toggle button:', toggleBtn);
        console.log('Sidebar:', sidebar);

        if (!toggleBtn) {
          console.error('Toggle button not found!');
          return;
        }
        if (!sidebar) {
          console.error('Sidebar not found!');
          return;
        }

        // Function to toggle sidebar
        function toggleSidebar() {
          console.log('Toggling sidebar...');
          const isOpen = sidebar.classList.toggle('open');
          toggleBtn.classList.toggle('open', isOpen);
          toggleBtn.setAttribute('aria-expanded', isOpen);
          toggleBtn.setAttribute('title', isOpen ? 'Hide image library' : 'Show image library');
          console.log('Sidebar is now:', isOpen ? 'open' : 'closed');
        }

        // Attach to floating toggle button
        toggleBtn.addEventListener('click', function(e) {
          console.log('Floating toggle button clicked!');
          toggleSidebar();
        });

        // Attach to print library button
        const printLibraryBtn = document.getElementById('print-library-btn');
        if (printLibraryBtn) {
          printLibraryBtn.addEventListener('click', function(e) {
            console.log('Print Library button clicked!');
            toggleSidebar();
          });
          console.log('Print Library button listener attached');
        }

        console.log('Toggle button event listeners attached');

        
      });


    </script>


  <div id="container">
    <!-- Left Panel: 2D Fabric Positioning -->
    <div id="left-panel">
      <div id="controls-header">
        <h1>Design Your Feedbag</h2>
      <div id="instructions">Use this tool to design your Feedbag exactly as you like it. Select one of the prints from our library or upload your own, then see what it looks like with interactive 3D Viewer.</div>
        <div class="panel-section">
          <h2>Panel Selection</h3>
           
          <div id="panel-toggle-buttons">
            <button class="toggle-btn active" data-panel="external" >External Panel</button>
            <button class="toggle-btn" data-panel="bottom" >Bottom Panel</button>
          </div>
        </div>

        <div class="panel-section">
          <h2 id="current-panel-name">Current Panel: External</h3>
          <button id="print-library-btn" class="library-btn">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 8px;">
              <rect x="3" y="3" width="7" height="7" />
              <rect x="14" y="3" width="7" height="7" />
              <rect x="3" y="14" width="7" height="7" />
              <rect x="14" y="14" width="7" height="7" />
            </svg>
            Print Library
          </button>
          <div class="file-input-wrapper">
            <label>Upload Your Own Image:</label>
            <input type="file" id="fabric-img-input" accept="image/*" />
          </div>

        </div>

        <button id="generate-btn" >Generate 3D Preview</button>
      </div>

      <div id="canvas-container">
        <canvas id="fabric-canvas"></canvas>
        <div class="canvas-instructions">
          Drag to move • Scroll to zoom
        </div>
      </div>
    </div>

    <!-- Right Panel: 3D Preview -->
    <div id="right-panel">
      <canvas id="c"></canvas>
    </div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
        "three/examples/jsm/loaders/OBJLoader.js": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/OBJLoader.js",
        "three/examples/jsm/loaders/MTLLoader.js": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/MTLLoader.js",
        "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader.js';
    import { MTLLoader } from 'three/examples/jsm/loaders/MTLLoader.js';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

    // ═══════════════════════════════════════════════════════════════
    // CONFIGURATION: Map each OBJ body/group to a texture or material
    // ═══════════════════════════════════════════════════════════════
    //
    // HOW TO USE:
    // 1. Find your body/group name from FeedbagOBJ.obj (e.g., "Pattern_25178")
    // 2. For textures: { type: "texture", image: "filename.png" }
    //    - Use filename only (e.g., "Donut.png") - will use imageBasePath below
    //    - Or use full URL (e.g., "https://example.com/texture.jpg")
    // 3. For solid colors: { type: "color", color: 0xRRGGBB }
    //    - Example: 0xeeeeee (light gray), 0xff0000 (red), 0x000000 (black)
    // 4. Bodies not listed will default to black (0x000000)
    //
    const BODY_MATERIAL_MAP = {
      // Bodies with texture images - specify the image filename or URL
      "Pattern_25178": { type: "texture", image: "Donut.png" },
      "Pattern_4474": { type: "texture", image: "Donut.png" },
      //"Pattern_304806": { type: "texture", image: "mesh.png" },
      //"Pattern_304806": { type: "texture", image: "Donut.png" },
      
      // Bodies with solid colors - specify hex color (e.g., 0xeeeeee, 0xff0000)
      "Pattern_304806": { type: "color", color: 0x80FFFFFF },
      "Pattern_157054": { type: "color", color: 0xeeeeee },
      "Pattern_157053": { type: "color", color: 0xeeeeee },
      "Pattern_700495": { type: "color", color: 0xeeeeee },

      // All other bodies not listed above will default to black (0x000000)
      // Add more bodies here as needed:
      // "Pattern_4474": { type: "color", color: 0xff0000 },
       //"Pattern_4474": { type: "texture", image: "MyFabric.png" },
      // "Pattern_25189": { type: "texture", image: "https://example.com/texture.jpg" },
    };

    // Default OBJ file URL or path
    const objURL = 'https://wompatuck-prints.s3.us-west-1.amazonaws.com/render/FeedbagOBJ.obj';

    // Default MTL file URL or path
    const mtlURL = 'FeedbagOBJ.mtl';

    // Base path for local images (leave empty if using full URLs)
    const imageBasePath = 'https://wompatuck-prints.s3.us-west-1.amazonaws.com/render/';

    // Texture offset adjustments for centering on 3D model
    // Adjust these values to center the texture on each part
    // Positive values move texture right/up, negative values move left/down
    const TEXTURE_OFFSETS = {
      external: { x: 0.5, y: 0.5 },  // Offset for Pattern_25178 (External Panel)
      bottom: { x: 0.5, y: 0.5 }     // Offset for Pattern_4474 (Bottom Panel)
    };

    // Texture repeat/scale adjustments to fix aspect ratio issues
    // Adjust these if texture appears stretched in one direction
    // Values > 1 = texture compressed/repeated, < 1 = texture stretched
    // For external: if image doesn't reach full width, DECREASE x value (e.g., 0.8)
    //               if image is stretched vertically, DECREASE y value
    const TEXTURE_REPEAT = {
      external: { x: 0.85, y: 1.30 },  // Adjusted: decreased x to stretch horizontally
      bottom: { x: 2.5, y: 2.5 }      // Repeat for Pattern_4474 (Bottom Panel)
    };

    // AVAILABLE BODIES IN FeedbagOBJ.obj:
    // Pattern_4474, Pattern_25178, Pattern_25179, Pattern_4474, Pattern_25185,
    // Pattern_25191, Pattern_304806, Pattern_700495, Pattern_25189, Pattern_25192,
    // Pattern_157053, Pattern_157054, Pattern_453128, Pattern_453129, Pattern_453130,
    // Pattern_453132, Pattern_453134, Pattern_453135, Pattern_453131, pHelix1 group1,
    // Topstitch_740533, Topstitch_740535, Topstitch_740337, Topstitch_740339,
    // Topstitch_751414, Topstitch_752179, Topstitch_742399, Topstitch_742782,
    // Topstitch_89825, Topstitch_97308, Topstitch_89908, Topstitch_97311
    // ═══════════════════════════════════════════════════════════════

    // ═══════════════════════════════════════════════════════════════
    // 2D FABRIC POSITIONING CANVAS
    // ═══════════════════════════════════════════════════════════════
    const fabricCanvas = document.getElementById('fabric-canvas');
    const fabricCtx = fabricCanvas.getContext('2d');

    // State for the two fabric panels
    const fabricPanels = {
      external: {
        image: null,
        x: 0,
        y: 0,
        scale: 1,
        svgPath: 'ExternalPanel.svg',
        svgWidth: 900,
        svgHeight: 550,
        clipPath: null,
        outlinePath: null,
        displayScale: 1,
        displayOffsetX: 0,
        displayOffsetY: 0,
        label: 'Current Panel: External'
      },
      bottom: {
        image: null,
        x: 0,
        y: 0,
        scale: 1,
        svgPath: 'BottomOutline.svg',
        svgWidth: 288,
        svgHeight: 288,
        clipPath: null,
        outlinePath: null,
        displayScale: 1,
        displayOffsetX: 0,
        displayOffsetY: 0,
        label: 'Current Panel: Bottom'
      }
    };

    let currentPanel = 'external'; // Which panel is currently being edited
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    let lastX = 0;
    let lastY = 0;
    let canvasContainerWidth = 0;
    let canvasContainerHeight = 0;

    // Expose to global scope for sidebar.js
    window.fabricPanels = fabricPanels;
    window.currentPanel = currentPanel;
    

    // Initialize 2D canvas
    function init2DCanvas() {
      // Get canvas container dimensions
      const canvasContainer = document.getElementById('canvas-container');
      canvasContainerWidth = canvasContainer.clientWidth;
      canvasContainerHeight = canvasContainer.clientHeight;

      // Calculate display scaling for each panel to fit in container with padding
      const padding = 40;
      for (const [key, panel] of Object.entries(fabricPanels)) {
        const scaleX = (canvasContainerWidth - padding * 2) / panel.svgWidth;
        const scaleY = (canvasContainerHeight - padding * 2) / panel.svgHeight;
        panel.displayScale = Math.min(scaleX, scaleY, 1); // Don't scale up, only down

        // Center the canvas
        const displayWidth = panel.svgWidth * panel.displayScale;
        const displayHeight = panel.svgHeight * panel.displayScale;
        panel.displayOffsetX = (canvasContainerWidth - displayWidth) / 2;
        panel.displayOffsetY = (canvasContainerHeight - displayHeight) / 2;
      }

      // Set initial canvas size
      updateCanvasSize();

      // Load SVG clip paths
      loadSVGClipPath('external');
      loadSVGClipPath('bottom');

      // Setup event listeners
      document.getElementById('fabric-img-input').addEventListener('change', handleFabricImageUpload);
      document.getElementById('generate-btn').addEventListener('click', generatePreview);

      // Toggle button listeners
      const toggleButtons = document.querySelectorAll('.toggle-btn');
      toggleButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          const panelName = btn.dataset.panel;
          switchToPanel(panelName);
        });
      });

      fabricCanvas.addEventListener('mousedown', onCanvasMouseDown);
      fabricCanvas.addEventListener('mousemove', onCanvasMouseMove);
      fabricCanvas.addEventListener('mouseup', onCanvasMouseUp);
      fabricCanvas.addEventListener('mouseleave', onCanvasMouseUp);
      fabricCanvas.addEventListener('wheel', onCanvasWheel, { passive: false });

      // Handle window resize
      window.addEventListener('resize', handleResize);

      render2DCanvas();
    }

    function handleResize() {
      const canvasContainer = document.getElementById('canvas-container');
      canvasContainerWidth = canvasContainer.clientWidth;
      canvasContainerHeight = canvasContainer.clientHeight;

      // Recalculate display scaling for each panel
      const padding = 40;
      for (const [key, panel] of Object.entries(fabricPanels)) {
        const scaleX = (canvasContainerWidth - padding * 2) / panel.svgWidth;
        const scaleY = (canvasContainerHeight - padding * 2) / panel.svgHeight;
        panel.displayScale = Math.min(scaleX, scaleY, 1);

        const displayWidth = panel.svgWidth * panel.displayScale;
        const displayHeight = panel.svgHeight * panel.displayScale;
        panel.displayOffsetX = (canvasContainerWidth - displayWidth) / 2;
        panel.displayOffsetY = (canvasContainerHeight - displayHeight) / 2;
      }

      updateCanvasSize();
      render2DCanvas();
    }

    function updateCanvasSize() {
      const panel = fabricPanels[currentPanel];
      const displayWidth = panel.svgWidth * panel.displayScale;
      const displayHeight = panel.svgHeight * panel.displayScale;

      fabricCanvas.width = displayWidth;
      fabricCanvas.height = displayHeight;

      // Center the canvas using CSS transform (already set in styles)
      // Remove any inline positioning that would override CSS
      fabricCanvas.style.left = '50%';
      fabricCanvas.style.top = '50%';
      fabricCanvas.style.transform = 'translate(-50%, -50%)';
    }

    function switchToPanel(panelName) {
      currentPanel = panelName;
      window.currentPanel = panelName; // Update global reference

      // Update toggle buttons
      document.querySelectorAll('.toggle-btn').forEach(btn => {
        if (btn.dataset.panel === panelName) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });

      // Update panel name
      const panel = fabricPanels[panelName];
      document.getElementById('current-panel-name').textContent = panel.label;

      // Update canvas size
      updateCanvasSize();

      // Re-render
      render2DCanvas();
    }

    function loadSVGClipPath(panelName) {
      const panel = fabricPanels[panelName];
      const img = new Image();
      img.onload = () => {
        panel.clipPath = img;

        // Create an outlined version of the SVG for preview
        createOutlineFromMask(img, panel.svgWidth, panel.svgHeight).then(outlineImg => {
          panel.outlinePath = outlineImg;
          render2DCanvas();
        });
      };
      img.src = panel.svgPath;
    }

    // Create an outline stroke from a filled SVG mask
    function createOutlineFromMask(maskImg, width, height) {
      return new Promise((resolve) => {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = width;
        tempCanvas.height = height;
        const tempCtx = tempCanvas.getContext('2d');

        // Draw the mask
        tempCtx.drawImage(maskImg, 0, 0, width, height);

        // Get image data to detect edges
        const imageData = tempCtx.getImageData(0, 0, width, height);
        const data = imageData.data;

        // Create a new canvas for the outline
        const outlineCanvas = document.createElement('canvas');
        outlineCanvas.width = width;
        outlineCanvas.height = height;
        const outlineCtx = outlineCanvas.getContext('2d');

        // Draw edges by detecting alpha changes
        outlineCtx.strokeStyle = '#507CBC';
        outlineCtx.lineWidth = 2;
        outlineCtx.beginPath();

        // Simple edge detection - look for alpha transitions
        for (let y = 1; y < height - 1; y++) {
          for (let x = 1; x < width - 1; x++) {
            const idx = (y * width + x) * 4;
            const alpha = data[idx + 3];

            // Check if this is an edge pixel (alpha changes from neighbor)
            const leftAlpha = data[(y * width + (x - 1)) * 4 + 3];
            const rightAlpha = data[(y * width + (x + 1)) * 4 + 3];
            const topAlpha = data[((y - 1) * width + x) * 4 + 3];
            const bottomAlpha = data[((y + 1) * width + x) * 4 + 3];

            if (alpha > 128 && (leftAlpha < 128 || rightAlpha < 128 || topAlpha < 128 || bottomAlpha < 128)) {
              outlineCtx.fillStyle = '#507CBC';
              outlineCtx.fillRect(x, y, 1, 1);
            }
          }
        }

        // Convert to image
        const outlineImg = new Image();
        outlineImg.onload = () => resolve(outlineImg);
        outlineImg.src = outlineCanvas.toDataURL();
      });
    }

    function handleFabricImageUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          const panel = fabricPanels[currentPanel];
          panel.image = img;

          // Scale the image to fill the entire canvas (cover mode)
          const imageAspect = img.width / img.height;
          const canvasAspect = panel.svgWidth / panel.svgHeight;

          if (imageAspect > canvasAspect) {
            // Image is wider - fit to height (fill vertically)
            panel.scale = panel.svgHeight / img.height;
          } else {
            // Image is taller - fit to width (fill horizontally)
            panel.scale = panel.svgWidth / img.width;
          }

          // Center the image
          panel.x = (panel.svgWidth - img.width * panel.scale) / 2;
          panel.y = (panel.svgHeight - img.height * panel.scale) / 2;

          render2DCanvas();
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);

      // Reset the file input value to allow re-uploading the same file
      event.target.value = '';
    }

    function onCanvasMouseDown(e) {
      const panel = fabricPanels[currentPanel];
      if (!panel.image) return;

      isDragging = true;
      const rect = fabricCanvas.getBoundingClientRect();
      dragStartX = (e.clientX - rect.left) / panel.displayScale;
      dragStartY = (e.clientY - rect.top) / panel.displayScale;
      lastX = panel.x;
      lastY = panel.y;
    }

    function onCanvasMouseMove(e) {
      if (!isDragging) return;

      const rect = fabricCanvas.getBoundingClientRect();
      const currentX = (e.clientX - rect.left) / fabricPanels[currentPanel].displayScale;
      const currentY = (e.clientY - rect.top) / fabricPanels[currentPanel].displayScale;

      const panel = fabricPanels[currentPanel];
      panel.x = lastX + (currentX - dragStartX);
      panel.y = lastY + (currentY - dragStartY);

      render2DCanvas();
    }

    function onCanvasMouseUp() {
      isDragging = false;
    }

    function onCanvasWheel(e) {
      e.preventDefault();

      const panel = fabricPanels[currentPanel];
      if (!panel.image) return;

      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      const newScale = Math.max(0.1, Math.min(5, panel.scale * delta));

      // Zoom towards mouse position (accounting for display scale)
      const rect = fabricCanvas.getBoundingClientRect();
      const mouseX = (e.clientX - rect.left) / panel.displayScale;
      const mouseY = (e.clientY - rect.top) / panel.displayScale;

      const scaleChange = newScale / panel.scale;
      panel.x = mouseX - (mouseX - panel.x) * scaleChange;
      panel.y = mouseY - (mouseY - panel.y) * scaleChange;
      panel.scale = newScale;

      render2DCanvas();
    }

    function render2DCanvas() {
      const panel = fabricPanels[currentPanel];

      fabricCtx.clearRect(0, 0, fabricCanvas.width, fabricCanvas.height);

      // Scale context to fit display
      fabricCtx.save();
      fabricCtx.scale(panel.displayScale, panel.displayScale);

      // Draw checkerboard background
      drawCheckerboard(fabricCtx, panel.svgWidth, panel.svgHeight);

      if (panel.image) {
        const imgWidth = panel.image.width * panel.scale;
        const imgHeight = panel.image.height * panel.scale;

        // Layer 1: Draw the full image at 25% opacity
        fabricCtx.globalAlpha = 1.0;
        fabricCtx.drawImage(panel.image, panel.x, panel.y, imgWidth, imgHeight);
        fabricCtx.globalAlpha = 1.0;

        // Layer 2: Draw the cropped image at 100% opacity (if we have a clipping mask)
        if (panel.clipPath) {
          // Save current state
          fabricCtx.save();

          // Create clipping region from the SVG mask
          fabricCtx.globalCompositeOperation = 'source-over';

          // Draw image again
          fabricCtx.drawImage(panel.image, panel.x, panel.y, imgWidth, imgHeight);

          // Apply mask to show only the clipped portion
          fabricCtx.globalCompositeOperation = 'destination-in';
          fabricCtx.drawImage(panel.clipPath, 0, 0, panel.svgWidth, panel.svgHeight);

          // Restore composite operation
          fabricCtx.globalCompositeOperation = 'source-over';

          fabricCtx.restore();
        }
      }

      // Layer 3: Draw the SVG outline stroke (no fill) on top
      if (panel.outlinePath) {
        fabricCtx.save();
        fabricCtx.globalAlpha = 1.0;
        fabricCtx.drawImage(panel.outlinePath, 0, 0, panel.svgWidth, panel.svgHeight);
        fabricCtx.restore();
      }

      fabricCtx.restore();
    }

    // Expose render2DCanvas to global scope for sidebar.js
    window.render2DCanvas = render2DCanvas;

    function drawCheckerboard(ctx, width, height) {
      const squareSize = 20;
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, width, height);

      ctx.fillStyle = '#e0e0e0';
      for (let y = 0; y < height; y += squareSize) {
        for (let x = 0; x < width; x += squareSize) {
          if ((x / squareSize + y / squareSize) % 2 === 0) {
            ctx.fillRect(x, y, squareSize, squareSize);
          }
        }
      }
    }

    // Generate textures from the positioned images
    async function generateFabricTextures() {
      const textures = {};

      // Resolution multiplier for higher quality textures (2x, 3x, or 4x)
      const TEXTURE_RESOLUTION_SCALE = 4;

      for (const [panelName, panel] of Object.entries(fabricPanels)) {
        if (!panel.image || !panel.clipPath) {
          console.log(`Skipping ${panelName}: image=${!!panel.image}, clipPath=${!!panel.clipPath}`);
          continue;
        }

        console.log(`Generating texture for ${panelName}:`, {
          svgSize: `${panel.svgWidth}x${panel.svgHeight}`,
          outputSize: `${panel.svgWidth * TEXTURE_RESOLUTION_SCALE}x${panel.svgHeight * TEXTURE_RESOLUTION_SCALE}`,
          imageSize: `${panel.image.width}x${panel.image.height}`,
          position: `x=${panel.x}, y=${panel.y}`,
          scale: panel.scale
        });

        // Create an offscreen canvas for this panel at higher resolution
        const offCanvas = document.createElement('canvas');
        offCanvas.width = panel.svgWidth * TEXTURE_RESOLUTION_SCALE;
        offCanvas.height = panel.svgHeight * TEXTURE_RESOLUTION_SCALE;
        const offCtx = offCanvas.getContext('2d');

        // Scale the context to render at higher resolution
        offCtx.scale(TEXTURE_RESOLUTION_SCALE, TEXTURE_RESOLUTION_SCALE);

        // Draw the positioned image
        const imgWidth = panel.image.width * panel.scale;
        const imgHeight = panel.image.height * panel.scale;
        offCtx.drawImage(panel.image, panel.x, panel.y, imgWidth, imgHeight);

        // Apply the SVG mask
        offCtx.globalCompositeOperation = 'destination-in';
        offCtx.drawImage(panel.clipPath, 0, 0, panel.svgWidth, panel.svgHeight);

        // Convert to texture with high quality
        textures[panelName] = offCanvas.toDataURL('image/png');
        console.log(`Generated ${panelName} texture at ${offCanvas.width}x${offCanvas.height}, data URL length: ${textures[panelName].length}`);
      }

      return textures;
    }

    // Download the cropped texture images
    function downloadCroppedImages(fabricTextures) {
      let delay = 0;
      for (const [panelName, dataUrl] of Object.entries(fabricTextures)) {
        if (!dataUrl) continue;

        // Add a small delay between downloads to prevent conflicts
        setTimeout(() => {
          // Create a temporary link element
          const link = document.createElement('a');
          link.download = `${panelName}_cropped_texture.png`;
          link.href = dataUrl;

          // Trigger download
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);

          console.log(`Downloaded ${panelName} texture`);
        }, delay);

        delay += 100; // 100ms delay between downloads
      }
    }

    // ═══════════════════════════════════════════════════════════════
    // 3D MODEL RENDERING
    // ═══════════════════════════════════════════════════════════════
    let camera, scene, renderer, controls;
    let objMesh = null;
    let defaultTexture = null;
    let currentModel = null; // Store reference to current 3D model
    let mtlMaterials = null; // Store materials loaded from MTL file

    init2DCanvas();
    init3D();
    loadModelWithDefaultTexture();

    function init3D() {
      const canvas = document.getElementById('c');

      const rightPanel = document.getElementById('right-panel');
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(rightPanel.clientWidth, rightPanel.clientHeight);

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f0f0);

      camera = new THREE.PerspectiveCamera(45, rightPanel.clientWidth / rightPanel.clientHeight, 0.1, 1000);
      camera.position.set(0, 0, 5);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // Lighting setup
      scene.add(new THREE.AmbientLight(0xffffff, 0.4));

      // Top directional light
      const topLight = new THREE.DirectionalLight(0xffffff, 0.3);
      topLight.position.set(0, 10, 0);
      scene.add(topLight);

      // Bottom directional light (illuminates the bottom surface)
      const bottomLight = new THREE.DirectionalLight(0xffffff, 0.2);
      bottomLight.position.set(0, -10, 0);
      scene.add(bottomLight);

      // Front light
      const frontLight = new THREE.DirectionalLight(0xffffff, 0.3);
      frontLight.position.set(0, 0, 10);
      scene.add(frontLight);

      // Back light
      const backLight = new THREE.DirectionalLight(0xffffff, 0.2);
      backLight.position.set(0, 0, -10);
      scene.add(backLight);

      // Side lights for even coverage
      const leftLight = new THREE.DirectionalLight(0xffffff, 0.2);
      leftLight.position.set(-10, 0, 0);
      scene.add(leftLight);

      const rightLight = new THREE.DirectionalLight(0xffffff, 0.2);
      rightLight.position.set(10, 0, 0);
      scene.add(rightLight);

      window.addEventListener('resize', () => {
        const rightPanel = document.getElementById('right-panel');
        camera.aspect = rightPanel.clientWidth / rightPanel.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(rightPanel.clientWidth, rightPanel.clientHeight);
      });

      animate3D();
    }

    function loadModelWithDefaultTexture() {
        const mtlLoader = new MTLLoader();
        const objLoader = new OBJLoader();
        const texLoader = new THREE.TextureLoader();

        // First, load the MTL file to get default materials
        mtlLoader.load(
          mtlURL,
          (materials) => {
            console.log('MTL materials loaded:', materials);
            mtlMaterials = materials;
            materials.preload();

            // Pre-load all unique textures from BODY_MATERIAL_MAP
            const textureCache = {};
            const texturesToLoad = new Set();

            Object.values(BODY_MATERIAL_MAP).forEach(config => {
              if (config.type === "texture" && config.image) {
                texturesToLoad.add(config.image);
              }
            });

            const texturePromises = Array.from(texturesToLoad).map(imageName => {
              return new Promise((resolve, reject) => {
                const imageUrl = imageName.startsWith('http') ? imageName : imageBasePath + imageName;
                texLoader.load(
                  imageUrl,
                  texture => {
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.wrapS  = THREE.RepeatWrapping;
                    texture.repeat.set(1, 1);
                    texture.flipY = true;
                    textureCache[imageName] = texture;
                    resolve();
                  },
                  undefined,
                  error => {
                    console.error(`Failed to load texture: ${imageName}`, error);
                    resolve(); // Continue even if texture fails
                  }
                );
              });
            });

            Promise.all(texturePromises).then(() => {
              objLoader.load(objURL, obj => {
                obj.traverse(child => {
                  if (child.isMesh) {
                    const config = BODY_MATERIAL_MAP[child.name];

                    if (config) {
                      // User has explicitly configured this mesh
                      if (config.type === "texture" && config.image) {
                        const texture = textureCache[config.image];
                        if (texture) {
                          child.material = new THREE.MeshStandardMaterial({ map: texture });
                        } else {
                          child.material = new THREE.MeshStandardMaterial({ color: 0x808080 });
                        }
                      } else if (config.type === "color") {
                        child.material = new THREE.MeshStandardMaterial({ color: config.color });
                      }
                    } else {
                      // Not explicitly configured - try to use MTL material
                      if (child.material && child.material.name && mtlMaterials.materials[child.material.name]) {
                        // Use the material from MTL file
                        const mtlMaterial = mtlMaterials.materials[child.material.name];
                        child.material = mtlMaterial;
                        console.log(`Applied MTL material "${child.material.name}" to ${child.name}`);
                      } else {
                        // No MTL material found - default to black
                        child.material = new THREE.MeshStandardMaterial({ color: 0x000000 });
                        console.log(`No material found for ${child.name}, defaulting to black`);
                      }
                    }
                  }
                });

                // Center camera on model
                const bbox = new THREE.Box3().setFromObject(obj);
                const center = bbox.getCenter(new THREE.Vector3());
                const size = bbox.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const fitDist = maxDim * 1.5;

                camera.position.set(center.x, center.y, center.z + fitDist);
                camera.lookAt(center);
                controls.target.copy(center);
                controls.update();

                scene.add(obj);
              });
            });
          },
          undefined,
          (error) => {
            console.error('Error loading MTL file:', error);
            // Fallback: load OBJ without MTL materials
            loadOBJWithoutMTL();
          }
        );

        // Fallback function to load OBJ without MTL
        function loadOBJWithoutMTL() {
          const texLoader = new THREE.TextureLoader();
          const textureCache = {};
          const texturesToLoad = new Set();

          Object.values(BODY_MATERIAL_MAP).forEach(config => {
            if (config.type === "texture" && config.image) {
              texturesToLoad.add(config.image);
            }
          });

          const texturePromises = Array.from(texturesToLoad).map(imageName => {
            return new Promise((resolve, reject) => {
              const imageUrl = imageName.startsWith('http') ? imageName : imageBasePath + imageName;
              texLoader.load(
                imageUrl,
                texture => {
                  texture.wrapT = THREE.RepeatWrapping;
                  texture.wrapS  = THREE.RepeatWrapping;
                  texture.repeat.set(1, 1);
                  texture.flipY = true;
                  textureCache[imageName] = texture;
                  resolve();
                },
                undefined,
                error => {
                  console.error(`Failed to load texture: ${imageName}`, error);
                  resolve();
                }
              );
            });
          });

          Promise.all(texturePromises).then(() => {
            objLoader.load(objURL, obj => {
              obj.traverse(child => {
                if (child.isMesh) {
                  const config = BODY_MATERIAL_MAP[child.name];

                  if (config) {
                    if (config.type === "texture" && config.image) {
                      const texture = textureCache[config.image];
                      if (texture) {
                        child.material = new THREE.MeshStandardMaterial({ map: texture });
                      } else {
                        child.material = new THREE.MeshStandardMaterial({ color: 0x808080 });
                      }
                    } else if (config.type === "color") {
                      child.material = new THREE.MeshStandardMaterial({ color: config.color });
                    }
                  } else {
                    child.material = new THREE.MeshStandardMaterial({ color: 0x000000 });
                  }
                }
              });

              const bbox = new THREE.Box3().setFromObject(obj);
              const center = bbox.getCenter(new THREE.Vector3());
              const size = bbox.getSize(new THREE.Vector3());
              const maxDim = Math.max(size.x, size.y, size.z);
              const fitDist = maxDim * 1.5;

              camera.position.set(center.x, center.y, center.z + fitDist);
              camera.lookAt(center);
              controls.target.copy(center);
              controls.update();

              scene.add(obj);
            });
          });
        }

      // const loader = new OBJLoader();
      // const texLoader = new THREE.TextureLoader();

      // texLoader.load(textureURL, texture => {
      //   defaultTexture = texture;
      //   texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      //   texture.repeat.set(1, 1);
      //   texture.flipY = false;

      //   loader.load(objURL, obj => {
      //     const targetParts = ["Pattern_25179", "Pattern_25178"];

      //     obj.traverse(child => {
      //       console.log('Part:', child.name);
      //       if (child.isMesh) {
      //         if (targetParts.includes(child.name)) {
      //           child.material = new THREE.MeshStandardMaterial({ map: fabricTexture });
      //         } else {
      //           child.material = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
      //         }
      //       }
      //     });

          

      //     // Center camera on model
      //     const bbox = new THREE.Box3().setFromObject(obj);
      //     const center = bbox.getCenter(new THREE.Vector3());
      //     const size = bbox.getSize(new THREE.Vector3());
      //     const maxDim = Math.max(size.x, size.y, size.z);
      //     const fitDist = maxDim * 1.5;

      //     camera.position.set(center.x, center.y, center.z + fitDist);
      //     camera.lookAt(center);
      //     controls.target.copy(center);
      //     controls.update();

      //     scene.add(obj);
      //   });
      // });

      
    }

    // Generate 3D Preview with positioned fabric textures
    async function generatePreview() {
      console.log("Generating 3D Preview...");

      // Clear the current scene
      while(scene.children.length > 0) {
        scene.remove(scene.children[0]);
      }

      // Re-add lighting with reduced intensity for better texture visibility
      scene.add(new THREE.AmbientLight(0xffffff, 0.6));

      // Add directional lights for depth
      const topLight = new THREE.DirectionalLight(0xffffff, 0.4);
      topLight.position.set(0, 10, 0);
      scene.add(topLight);

      const frontLight = new THREE.DirectionalLight(0xffffff, 0.4);
      frontLight.position.set(0, 0, 10);
      scene.add(frontLight);

      // // Top directional light
      // const topLight = new THREE.DirectionalLight(0xffffff, 0.25);
      // topLight.position.set(0, 10, 0);
      // scene.add(topLight);

      // // Bottom directional light (illuminates the bottom surface)
      // const bottomLight = new THREE.DirectionalLight(0xffffff, 0.25);
      // bottomLight.position.set(0, -10, 0);
      // scene.add(bottomLight);

      // // Front light
      // const frontLight = new THREE.DirectionalLight(0xffffff, 0.125);
      // frontLight.position.set(0, 0, 10);
      // scene.add(frontLight);

      // // Back light
      // const backLight = new THREE.DirectionalLight(0xffffff, 0.125);
      // backLight.position.set(0, 0, -10);
      // scene.add(backLight);

      // Side lights for even coverage
      // const leftLight = new THREE.DirectionalLight(0xffffff, 0.4);
      // leftLight.position.set(-10, 0, 0);
      // scene.add(leftLight);

      // const rightLight = new THREE.DirectionalLight(0xffffff, 0.4);
      // rightLight.position.set(10, 0, 0);
      // scene.add(rightLight);

      // Generate textures from the 2D canvas
      const fabricTextures = await generateFabricTextures();

      // Download the cropped images for debugging
      //downloadCroppedImages(fabricTextures);

      const loader = new OBJLoader();
      const texLoader = new THREE.TextureLoader();

      // Load custom textures from the 2D canvas
      const textureCache = {};

      // Load external panel texture (Pattern_25178)
      if (fabricTextures.external) {
        const texture = texLoader.load(fabricTextures.external);

        // === WRAPPING OPTIONS ===
        // THREE.ClampToEdgeWrapping - Stretches edge pixels (no repeat)
        // THREE.RepeatWrapping - Tiles/repeats the texture
        // THREE.MirroredRepeatWrapping - Tiles with mirroring
        texture.wrapS = THREE.ClampToEdgeWrapping;
        texture.wrapT = THREE.ClampToEdgeWrapping;

        // === REPEAT/SCALE ===
        // repeat.set(x, y) - How many times texture repeats
        // Values > 1 = texture repeats, < 1 = texture zooms in
        texture.repeat.set(TEXTURE_REPEAT.external.x, TEXTURE_REPEAT.external.y);

        // === FLIP ===
        texture.flipY = true;

        // === ROTATION ===
        // texture.rotation = Math.PI / 2; // 90 degrees clockwise
        // texture.center.set(0.5, 0.5); // Rotation center point (0.5, 0.5 = center)

        // === OFFSET/POSITION ===
        // offset.set(x, y) - Shifts texture position
        // Positive = right/up, Negative = left/down
        texture.offset.set(TEXTURE_OFFSETS.external.x, TEXTURE_OFFSETS.external.y);

        console.log('═══════════════════════════════════════');
        console.log('EXTERNAL PANEL TEXTURE (Pattern_25178)');
        console.log('═══════════════════════════════════════');
        console.log('Texture Properties:');
        console.log(`  - wrapS: ${texture.wrapS === THREE.ClampToEdgeWrapping ? 'ClampToEdgeWrapping' : texture.wrapS === THREE.RepeatWrapping ? 'RepeatWrapping' : 'MirroredRepeatWrapping'}`);
        console.log(`  - wrapT: ${texture.wrapT === THREE.ClampToEdgeWrapping ? 'ClampToEdgeWrapping' : texture.wrapT === THREE.RepeatWrapping ? 'RepeatWrapping' : 'MirroredRepeatWrapping'}`);
        console.log(`  - repeat: (${texture.repeat.x}, ${texture.repeat.y})`);
        console.log(`  - offset: (${texture.offset.x}, ${texture.offset.y})`);
        console.log(`  - rotation: ${texture.rotation} radians (${(texture.rotation * 180 / Math.PI).toFixed(1)}°)`);
        console.log(`  - center: (${texture.center.x}, ${texture.center.y})`);
        console.log(`  - flipY: ${texture.flipY}`);
        console.log('\nTo fix stretching, adjust TEXTURE_REPEAT at top of file:');
        console.log('  - If stretched horizontally: increase external.x');
        console.log('  - If stretched vertically: increase external.y');
        console.log('  - If compressed: decrease the corresponding value');

        textureCache['external'] = texture;
      }

      // Load bottom panel texture (Pattern_4474)
      if (fabricTextures.bottom) {
        const texture = texLoader.load(fabricTextures.bottom);

        // === WRAPPING OPTIONS ===
        texture.wrapS = THREE.ClampToEdgeWrapping;
        texture.wrapT = THREE.ClampToEdgeWrapping;

        // === REPEAT/SCALE ===
        texture.repeat.set(TEXTURE_REPEAT.bottom.x, TEXTURE_REPEAT.bottom.y);

        // === FLIP ===
        texture.flipY = true;

        // === OFFSET/POSITION ===
        texture.offset.set(TEXTURE_OFFSETS.bottom.x, TEXTURE_OFFSETS.bottom.y);

        console.log('═══════════════════════════════════════');
        console.log('BOTTOM PANEL TEXTURE (Pattern_4474)');
        console.log('═══════════════════════════════════════');
        console.log('Texture Properties:');
        console.log(`  - wrapS: ${texture.wrapS === THREE.ClampToEdgeWrapping ? 'ClampToEdgeWrapping' : texture.wrapS === THREE.RepeatWrapping ? 'RepeatWrapping' : 'MirroredRepeatWrapping'}`);
        console.log(`  - wrapT: ${texture.wrapT === THREE.ClampToEdgeWrapping ? 'ClampToEdgeWrapping' : texture.wrapT === THREE.RepeatWrapping ? 'RepeatWrapping' : 'MirroredRepeatWrapping'}`);
        console.log(`  - repeat: (${texture.repeat.x}, ${texture.repeat.y})`);
        console.log(`  - offset: (${texture.offset.x}, ${texture.offset.y})`);
        console.log(`  - rotation: ${texture.rotation} radians (${(texture.rotation * 180 / Math.PI).toFixed(1)}°)`);
        console.log(`  - center: (${texture.center.x}, ${texture.center.y})`);
        console.log(`  - flipY: ${texture.flipY}`);

        textureCache['bottom'] = texture;
      }

      // Load the 3D model
      loader.load(objURL, obj => {
        console.log("=== Loading 3D Model ===");
        console.log("Available textures:", Object.keys(textureCache));

        // First pass: log all mesh names
        const meshNames = [];
        obj.traverse(child => {
          if (child.isMesh) {
            meshNames.push(child.name);
          }
        });
        console.log("All mesh names in OBJ:", meshNames);

        let pattern25178Count = 0;
        let pattern4474Count = 0;

        obj.traverse(child => {
          if (child.isMesh) {
            const config = BODY_MATERIAL_MAP[child.name];

            if (child.name === "Pattern_25178") {
              pattern25178Count++;
              if (textureCache['external']) {
                console.log(`\n✓ Applying EXTERNAL texture to Pattern_25178 (instance ${pattern25178Count})`);

                // Log mesh geometry info
                console.log(`  Mesh Info:`);
                console.log(`    - Vertices: ${child.geometry.attributes.position.count}`);
                console.log(`    - Faces: ${child.geometry.index ? child.geometry.index.count / 3 : 'N/A'}`);
                console.log(`    - Has UV mapping: ${!!child.geometry.attributes.uv}`);
                if (child.geometry.attributes.uv) {
                  const uvArray = child.geometry.attributes.uv.array;
                  console.log(`    - UV coordinates count: ${uvArray.length / 2}`);

                  // Calculate UV min/max without spread operator (avoids stack overflow)
                  let minU = Infinity, maxU = -Infinity, minV = Infinity, maxV = -Infinity;
                  for (let i = 0; i < uvArray.length; i += 2) {
                    const u = uvArray[i];
                    const v = uvArray[i + 1];
                    if (u < minU) minU = u;
                    if (u > maxU) maxU = u;
                    if (v < minV) minV = v;
                    if (v > maxV) maxV = v;
                  }
                  console.log(`    - UV range: U[${minU.toFixed(3)}, ${maxU.toFixed(3)}], V[${minV.toFixed(3)}, ${maxV.toFixed(3)}]`);
                }

                // Calculate mesh bounds
                child.geometry.computeBoundingBox();
                const bbox = child.geometry.boundingBox;
                console.log(`    - Bounding box:`);
                console.log(`      Min: (${bbox.min.x.toFixed(2)}, ${bbox.min.y.toFixed(2)}, ${bbox.min.z.toFixed(2)})`);
                console.log(`      Max: (${bbox.max.x.toFixed(2)}, ${bbox.max.y.toFixed(2)}, ${bbox.max.z.toFixed(2)})`);
                console.log(`      Size: (${(bbox.max.x - bbox.min.x).toFixed(2)}, ${(bbox.max.y - bbox.min.y).toFixed(2)}, ${(bbox.max.z - bbox.min.z).toFixed(2)})`);

                child.material = new THREE.MeshStandardMaterial({
                  map: textureCache['external'],
                  roughness: 0.8,
                  metalness: 0.0
                });
              } else {
                console.log(`✗ No external texture available for Pattern_25178`);
                child.material = new THREE.MeshStandardMaterial({ color: 0xff0000 }); // Red for debugging
              }
            } else if (child.name === "Pattern_4474") {
              pattern4474Count++;
              if (textureCache['bottom']) {
                console.log(`\n✓ Applying BOTTOM texture to Pattern_4474 (instance ${pattern4474Count})`);

                // Log mesh geometry info
                console.log(`  Mesh Info:`);
                console.log(`    - Vertices: ${child.geometry.attributes.position.count}`);
                console.log(`    - Faces: ${child.geometry.index ? child.geometry.index.count / 3 : 'N/A'}`);
                console.log(`    - Has UV mapping: ${!!child.geometry.attributes.uv}`);
                if (child.geometry.attributes.uv) {
                  const uvArray = child.geometry.attributes.uv.array;
                  console.log(`    - UV coordinates count: ${uvArray.length / 2}`);

                  // Calculate UV min/max without spread operator (avoids stack overflow)
                  let minU = Infinity, maxU = -Infinity, minV = Infinity, maxV = -Infinity;
                  for (let i = 0; i < uvArray.length; i += 2) {
                    const u = uvArray[i];
                    const v = uvArray[i + 1];
                    if (u < minU) minU = u;
                    if (u > maxU) maxU = u;
                    if (v < minV) minV = v;
                    if (v > maxV) maxV = v;
                  }
                  console.log(`    - UV range: U[${minU.toFixed(3)}, ${maxU.toFixed(3)}], V[${minV.toFixed(3)}, ${maxV.toFixed(3)}]`);
                }

                // Calculate mesh bounds
                child.geometry.computeBoundingBox();
                const bbox = child.geometry.boundingBox;
                console.log(`    - Bounding box:`);
                console.log(`      Min: (${bbox.min.x.toFixed(2)}, ${bbox.min.y.toFixed(2)}, ${bbox.min.z.toFixed(2)})`);
                console.log(`      Max: (${bbox.max.x.toFixed(2)}, ${bbox.max.y.toFixed(2)}, ${bbox.max.z.toFixed(2)})`);
                console.log(`      Size: (${(bbox.max.x - bbox.min.x).toFixed(2)}, ${(bbox.max.y - bbox.min.y).toFixed(2)}, ${(bbox.max.z - bbox.min.z).toFixed(2)})`);

                child.material = new THREE.MeshStandardMaterial({
                  map: textureCache['bottom'],
                  roughness: 0.8,
                  metalness: 0.0
                });
              } else {
                console.log(`✗ No bottom texture available for Pattern_4473`);
                child.material = new THREE.MeshStandardMaterial({ color: 0x00ff00 }); // Green for debugging
              }
            } else if (config) {
              // User has explicitly configured this mesh
              if (config.type === "color") {
                child.material = new THREE.MeshStandardMaterial({ color: config.color });
              } else {
                child.material = new THREE.MeshStandardMaterial({ color: 0x808080 });
              }
            } else {
              // Not explicitly configured - try to use MTL material
              if (child.material && child.material.name && mtlMaterials && mtlMaterials.materials[child.material.name]) {
                const mtlMaterial = mtlMaterials.materials[child.material.name];
                child.material = mtlMaterial;
                console.log(`Applied MTL material "${child.material.name}" to ${child.name}`);
              } else {
                child.material = new THREE.MeshStandardMaterial({ color: 0x000000 });
                console.log(`No material found for ${child.name}, defaulting to black`);
              }
            }
          }
        });

        console.log(`Found ${pattern25178Count} instances of Pattern_25178`);
        console.log(`Found ${pattern4474Count} instances of Pattern_4474`);

        // Center camera on model
        const bbox = new THREE.Box3().setFromObject(obj);
        const center = bbox.getCenter(new THREE.Vector3());
        const size = bbox.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        const fitDist = maxDim * 1.5;

        camera.position.set(center.x, center.y, center.z + fitDist);
        camera.lookAt(center);
        controls.target.copy(center);
        controls.update();

        currentModel = obj;
        scene.add(obj);

        console.log("3D Preview generated successfully!");
      });
    }

    function animate3D() {
      requestAnimationFrame(animate3D);
      controls.update();
      renderer.render(scene, camera);
    }

    
  </script>
</body>
</html>
