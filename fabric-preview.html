<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Fabric Bag Preview</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    #container {
      display: flex;
      width: 100vw;
      height: 100vh;
    }

    /* Left Panel - 2D Fabric Positioning */
    #left-panel {
      width: 40%;
      background: #f5f5f5;
      display: flex;
      flex-direction: column;
      border-right: 2px solid #ccc;
    }

    #controls-header {
      background: white;
      padding: 10px;
      border-bottom: 1px solid #ddd;
    }

    #controls-header h1 {
      margin: 0 0 15px 0;
      font-size: 30px;
      color: #333;
    }

    #controls-header h2 {
      margin: 0 0 15px 0;
      font-size: 20px;
      color: #333;
    }


    .panel-section {
      margin-bottom: 10px;
      margin-top: 10px;
    }

    .panel-section h3 {
      margin: 0 0 10px 0;
      font-size: 14px;
      font-weight: 600;
      color: #666;
      text-transform: uppercase;
    }

    .file-input-wrapper {
      display: flex;
      gap: 5 px;
      align-items: center;
      margin-bottom: 10px;
      margin-top: 20px;
    }

    .file-input-wrapper label {
      flex: 1;
      display: block;
      font-size: 16px;
      color: #444;
    }

    .file-input-wrapper input[type="file"] {
      font-size: 16px;
    }

    .load-bag-section {
      margin-top: 15px;
      padding: 25px;
      border-top: 1px solid #e0e0e0;
    }

    .load-bag-section label {
      display: block;
      font-size: 13px;
      color: #444;
      margin-bottom: 8px;
      font-weight: 500;
    }

    .load-bag-controls {
      display: flex;
      gap: 8px;
    }

    #load-bag-input {
      flex: 1;
      padding: 8px 12px;
      border: 2px solid #dee2e6;
      border-radius: 4px;
      font-size: 13px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      transition: border-color 0.2s;
    }

    #load-bag-input:focus {
      outline: none;
      border-color: #507CBC;
    }

    .load-bag-button {
      padding: 8px 20px;
      background: #507CBC;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
      white-space: nowrap;
    }

    .load-bag-button:hover {
      background: #3d5f99;
    }

    .load-bag-button:active {
      background: #2a4570;
    }

    .load-bag-button:disabled {
      background: #adb5bd;
      cursor: not-allowed;
    }

    #panel-toggle-buttons {
      display: flex;
      gap: 10px;
    }

    .toggle-btn {
      flex: 1;
      padding: 10px 15px;
      background: #e9ecef;
      color: #495057;
      border: 2px solid #dee2e6;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .toggle-btn:hover {
      background: #dee2e6;
      border-color: #adb5bd;
    }

    .toggle-btn.active {
      background: #507CBC;
      color: white;
      border-color: #507CBC;
    }

    .library-btn {
      width: 100%;
      padding: 10px 15px;
      margin-top: 10px;
      background: white;
      color: #507CBC;
      border: 2px solid #507CBC;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .library-btn:hover {
      background: #507CBC;
      color: white;
    }

    .library-btn:hover svg {
      stroke: white;
    }

    #generate-btn {
      width: 100%;
      padding: 12px 20px;
      background: #507CBC;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s;
    }

    #generate-btn:hover {
      background: #218838;
    }

    #generate-btn:active {
      background: #1e7e34;
    }

    #add-to-cart-btn {
      width: 100%;
      padding: 14px 20px;
      margin-top: 15px;
      background: #28a745;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 18px;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
    }

    #add-to-cart-btn:hover {
      background: #218838;
      transform: translateY(-2px);
      box-shadow: 0 6px 16px rgba(40, 167, 69, 0.4);
    }

    #add-to-cart-btn:active {
      background: #1e7e34;
      transform: translateY(0);
      box-shadow: 0 2px 8px rgba(40, 167, 69, 0.3);
    }

    #bag-id-display {
      margin-top: 10px;
      padding: 8px 12px;
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 4px;
      text-align: center;
    }

    #canvas-container {
      flex: 1;
      position: relative;
      overflow: hidden;
      background: white;
    }

    #fabric-canvas {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      border: 1px solid #ddd;
      cursor: grab;
    }

    #fabric-canvas:active {
      cursor: grabbing;
    }

    .canvas-instructions {
      position: absolute;
      bottom: 5px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px 20px;
      border-radius: 20px;
      font-size: 10px;
      pointer-events: none;
    }

    /* Right Panel - 3D Preview */
    #right-panel {
      width: 70%;
      position: relative;
      background: #f0f0f0;
    }

    #c {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* Image Library Sidebar */
    #fabric-menu-side {
      position: fixed;
      right: -350px;
      top: 0;
      width: 350px;
      height: 100vh;
      background: white;
      box-shadow: -2px 0 10px rgba(0,0,0,0.2);
      transition: right 0.3s ease;
      z-index: 1000;
      overflow-y: auto;
    }

    #fabric-menu-side.open {
      right: 0;
    }

    #fabric-toggle {
      position: fixed;
      right: 10px;
      top: 10px;
      width: 50px;
      height: 50px;
      background: #507CBC;
      color: white;
      border: none;
      border-radius: 8px;
      font-size: 24px;
      font-weight: bold;
      cursor: pointer;
      z-index: 1001;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      transition: all 0.3s ease;
    }

    #fabric-toggle:hover {
      background: #3d5f99;
      transform: scale(1.05);
    }

    #fabric-toggle.open {
      right: 360px;
    }

    .image-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      padding: 20px;
    }

    .image-item {
      aspect-ratio: 1;
      border: 2px solid #ddd;
      border-radius: 8px;
      overflow: hidden;
      cursor: pointer;
      transition: all 0.2s ease;
      background: #f9f9f9;
    }

    .image-item:hover {
      border-color: #507CBC;
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(80, 124, 188, 0.3);
    }

    .image-item.selected {
      border-color: #507CBC;
      border-width: 3px;
      box-shadow: 0 4px 12px rgba(80, 124, 188, 0.5);
    }

    .image-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    /* Loading Indicator */
    #loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }

    #loading-overlay.visible {
      display: flex;
    }

    .loading-content {
      background: white;
      padding: 40px;
      border-radius: 12px;
      text-align: center;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .spinner {
      width: 60px;
      height: 60px;
      margin: 0 auto 20px;
      border: 6px solid #f3f3f3;
      border-top: 6px solid #507CBC;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .loading-text {
      font-size: 18px;
      font-weight: 600;
      color: #333;
      margin-bottom: 8px;
    }

    .loading-subtext {
      font-size: 14px;
      color: #666;
    }
  </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div id="loading-overlay">
      <div class="loading-content">
        <div class="spinner"></div>
        <div class="loading-text">Generating 3D Preview</div>
        <div class="loading-subtext">Please wait...</div>
      </div>
    </div>

    <button id="fabric-toggle" type="button" aria-controls="fabric-menu-side" aria-expanded="false" title="Show image library">
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="3" y="3" width="7" height="7" />
        <rect x="14" y="3" width="7" height="7" />
        <rect x="3" y="14" width="7" height="7" />
        <rect x="14" y="14" width="7" height="7" />
      </svg>
    </button>

    <div
      id="fabric-menu-side"
      data-bucket="wompatuck-prints"
      data-prefix="prints/"
      data-baseurl="https://wompatuck-prints.s3.us-west-1.amazonaws.com/"
      data-max="1000"
    ></div>
    <script src="sidebar.js"></script>
    <script>
      // Toggle sidebar functionality
      document.addEventListener('DOMContentLoaded', function() {
        const toggleBtn = document.getElementById('fabric-toggle');
        const sidebar = document.getElementById('fabric-menu-side');

        console.log('Toggle button:', toggleBtn);
        console.log('Sidebar:', sidebar);

        if (!toggleBtn) {
          console.error('Toggle button not found!');
          return;
        }
        if (!sidebar) {
          console.error('Sidebar not found!');
          return;
        }

        // Function to toggle sidebar
        function toggleSidebar() {
          console.log('Toggling sidebar...');
          const isOpen = sidebar.classList.toggle('open');
          toggleBtn.classList.toggle('open', isOpen);
          toggleBtn.setAttribute('aria-expanded', isOpen);
          toggleBtn.setAttribute('title', isOpen ? 'Hide image library' : 'Show image library');
          console.log('Sidebar is now:', isOpen ? 'open' : 'closed');
        }

        // Attach to floating toggle button
        toggleBtn.addEventListener('click', function(e) {
          console.log('Floating toggle button clicked!');
          toggleSidebar();
        });

        // Attach to print library button
        const printLibraryBtn = document.getElementById('print-library-btn');
        if (printLibraryBtn) {
          printLibraryBtn.addEventListener('click', function(e) {
            console.log('Print Library button clicked!');
            toggleSidebar();
          });
          console.log('Print Library button listener attached');
        }

        console.log('Toggle button event listeners attached');

        
      });


    </script>


  <div id="container">
    <!-- Left Panel: 2D Fabric Positioning -->
    <div id="left-panel">
      <div id="controls-header">
        <h1 id="bag-title">Design Your Bag</h1>
        <div id="instructions">Use this tool to design your bag exactly as you like it. Select one of the prints from our library or upload your own, then see what it looks like with interactive 3D Viewer.</div>
        <div class="panel-section">
          <h2>1. Select a Panel</h2>

          <div id="panel-toggle-buttons">
            <!-- Buttons will be dynamically generated based on bag configuration -->
          </div>
        </div>

        <div class="panel-section">
          <h2 id="current-panel-name">2. Apply A Print or Upload your Own</h3>
          <button id="print-library-btn" class="library-btn">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="vertical-align: middle; margin-right: 8px;">
              <rect x="3" y="3" width="7" height="7" />
              <rect x="14" y="3" width="7" height="7" />
              <rect x="3" y="14" width="7" height="7" />
              <rect x="14" y="14" width="7" height="7" />
            </svg>
            Print Library
          </button>
          <div class="file-input-wrapper">
            <label>Upload Your Own Image:</label>
            <input type="file" id="fabric-img-input" accept="image/*" />
          </div>
          <h2 id="generate_header">3. Preview & Confirm Design</h3>

          
        </div>

        <button id="generate-btn" >Preview Design</button>
        <div id="bag-id-display" style="display: none;">
          <span style="font-size: 12px; color: #666;">Bag ID:</span>
          <span id="bag-id-value" style="font-size: 13px; font-weight: 600; color: #507CBC; margin-left: 5px;"></span>
        </div>
        <button id="add-to-cart-btn" style="display: none;">Add to Cart</button>
      </div>

      <div id="canvas-container">
        <canvas id="fabric-canvas"></canvas>
        <div class="canvas-instructions">
          Drag to move • Scroll to zoom
        </div>
      </div>
      <!-- <div class="load-bag-section">
            <label for="load-bag-input">Load Saved Bag:</label>
            <div class="load-bag-controls">
              <input type="text" id="load-bag-input" placeholder="Enter Bag ID" />
              <button id="load-bag-btn" class="load-bag-button">Load</button>
            </div>
          </div> -->

    </div>

    <!-- Right Panel: 3D Preview -->
    <div id="right-panel">
      <canvas id="c"></canvas>
    </div>
  </div>
  <script src="s3-api.js"></script>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
        "three/examples/jsm/loaders/OBJLoader.js": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/OBJLoader.js",
        "three/examples/jsm/loaders/MTLLoader.js": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/MTLLoader.js",
        "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js"
      }
    }
  </script>

  <script type="module">

    import * as THREE from 'three';
    import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader.js';
    import { MTLLoader } from 'three/examples/jsm/loaders/MTLLoader.js';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

    // ═══════════════════════════════════════════════════════════════
    // BAG CONFIGURATIONS
    // ═══════════════════════════════════════════════════════════════
    //
    // This section defines all bag types and their customizable panels.
    // The software will adapt automatically based on the selected configuration.
    //
    // HOW TO ADD A NEW BAG TYPE:
    // 1. Add a new entry to BAG_CONFIGS with a unique key (e.g., "mystyle")
    // 2. Configure the following properties:
    //
    //    name: Display name shown to users (e.g., "My Style Bag")
    //    objURL: Full URL to the 3D model OBJ file
    //    mtlURL: Filename or URL to the MTL material file
    //    imageBasePath: Base URL where texture images are stored
    //
    //    panels: Array of customizable panels, each with:
    //      - id: Unique identifier (e.g., "front", "back", "side")
    //            Used in filenames: {bagID}_{id}panel.png
    //      - label: Display name for the panel (e.g., "Front Panel")
    //      - svgPath: Path to SVG clipping mask file
    //      - svgWidth: Width of the SVG clipping mask in pixels
    //      - svgHeight: Height of the SVG clipping mask in pixels
    //      - objPart: Name of the 3D model mesh to apply texture to
    //                 (Find this in your OBJ file, e.g., "Pattern_25178")
    //      - textureOffset: { x, y } - Fine-tune texture position on 3D model
    //                       (0.5, 0.5 = centered, adjust to fix alignment)
    //      - textureRepeat: { x, y } - Scale/stretch texture on 3D model
    //                       (1.0 = normal, >1 = compressed, <1 = stretched)
    //
    //    bodyMaterialMap: Define materials for non-customizable parts
    //      - Use { type: "color", color: 0xRRGGBB } for solid colors
    //      - Parts not listed default to black or MTL material if available
    //
    // 3. Users can then load your bag with: ?config=mystyle
    //    Or set it as the default by changing line 709
    //
    // EXAMPLE:
    //   mybag: {
    //     name: "My Bag",
    //     objURL: "https://example.com/mybag.obj",
    //     mtlURL: "mybag.mtl",
    //     imageBasePath: "https://example.com/textures/",
    //     panels: [
    //       {
    //         id: "main",
    //         label: "Main Panel",
    //         svgPath: "MyBagMain.svg",
    //         svgWidth: 800,
    //         svgHeight: 600,
    //         objPart: "Pattern_Main",
    //         textureOffset: { x: 0.5, y: 0.5 },
    //         textureRepeat: { x: 1.0, y: 1.0 }
    //       }
    //     ],
    //     bodyMaterialMap: {
    //       "Pattern_Straps": { type: "color", color: 0x000000 }
    //     }
    //   }
    //
    // ═══════════════════════════════════════════════════════════════
    const BAG_CONFIGS = {
      feedbag: {
        name: "Feedbag",
        objURL: "https://wompatuck-prints.s3.us-west-1.amazonaws.com/render/FeedbagOBJ.obj",
        mtlURL: "FeedbagOBJ.mtl",
        imageBasePath: "https://wompatuck-prints.s3.us-west-1.amazonaws.com/render/",
        panels: [
          {
            id: "external",
            label: "External Panel",
            svgPath: "ExternalPanel.svg",
            svgWidth: 900,
            svgHeight: 550,
            objPart: "Pattern_25178",  // 3D model part name
            textureOffset: { x: 0.5, y: 0.5 },
            textureRepeat: { x: 0.85, y: 1.30 }
          },
          {
            id: "bottom",
            label: "Bottom Panel",
            svgPath: "BottomOutline.svg",
            svgWidth: 288,
            svgHeight: 288,
            objPart: "Pattern_4474",
            textureOffset: { x: 0.5, y: 0.5 },
            textureRepeat: { x: 2.5, y: 2.5 }
          }
        ],
        bodyMaterialMap: {
          // Solid color parts
          "Pattern_304806": { type: "color", color: 0x80FFFFFF },
          "Pattern_157054": { type: "color", color: 0xeeeeee },
          "Pattern_157053": { type: "color", color: 0xeeeeee },
          "Pattern_700495": { type: "color", color: 0xeeeeee }
        }
      },

      handlebar: {
        name: "Handlebar Bag",
        objURL: "https://wompatuck-prints.s3.us-west-1.amazonaws.com/render/HandlebarOBJ.obj",
        mtlURL: "HandlebarOBJ.mtl",
        imageBasePath: "https://wompatuck-prints.s3.us-west-1.amazonaws.com/render/",
        panels: [
          {
            id: "main",
            label: "Main Panel",
            svgPath: "Handlebar Pattern MASTER_External.svg",
            svgWidth: 1039,
            svgHeight: 539,
            objPart: "Pattern_686559",
            textureOffset: { x: 0.5, y: 0.5 },
            textureRepeat: { x: 1.0, y: 1.0 }
          },
          {
            id: "left",
            label: "Left Panel",
            svgPath: "Handlebar Pattern MASTER_EndCap.svg",
            svgWidth: 400,
            svgHeight: 400,
            objPart: "Pattern_177517",
            textureOffset: { x: 0.5, y: 0.5 },
            textureRepeat: { x: 1.0, y: 1.0 }
          },
                    {
            id: "right",
            label: "Right Panel",
            svgPath: "Handlebar Pattern MASTER_EndCap.svg",
            svgWidth: 400,
            svgHeight: 400,
            objPart: "Pattern_177518",
            textureOffset: { x: 0.5, y: 0.5 },
            textureRepeat: { x: 1.0, y: 1.0 }
          }
        ],
        bodyMaterialMap: {
          "Pattern_686560": { type: "color", color: 0x000000 },
          "Pattern_686561": { type: "color", color: 0xFFFFFF }
        }
      },

      minishoulder: {
        name: "Mini Shoulder Bag",
        objURL: "https://wompatuck-prints.s3.us-west-1.amazonaws.com/render/MiniShoulderOBJ.obj",
        mtlURL: "MiniShoulderOBJ.mtl",
        imageBasePath: "https://wompatuck-prints.s3.us-west-1.amazonaws.com/render/",
        panels: [
          {
            id: "front",
            label: "Front Panel",
            svgPath: "MiniShoulderFront.svg",
            svgWidth: 400,
            svgHeight: 400,
            objPart: "Pattern_Front",
            textureOffset: { x: 0.5, y: 0.5 },
            textureRepeat: { x: 1.0, y: 1.0 }
          },
                    {
            id: "right",
            label: "Right Panel",
            svgPath: "MiniShoulderFront.svg",
            svgWidth: 400,
            svgHeight: 400,
            objPart: "Pattern_Front",
            textureOffset: { x: 0.5, y: 0.5 },
            textureRepeat: { x: 1.0, y: 1.0 }
          },
          {
            id: "left",
            label: "Left Panel",
            svgPath: "MiniShoulderBack.svg",
            svgWidth: 400,
            svgHeight: 400,
            objPart: "Pattern_Back",
            textureOffset: { x: 0.5, y: 0.5 },
            textureRepeat: { x: 1.0, y: 1.0 }
          }
        ],
        bodyMaterialMap: {
          "Pattern_Strap": { type: "color", color: 0x000000 },
          "Pattern_Zipper": { type: "color", color: 0x808080 }
        }
      },

      toolroll: {
        name: "Tool Roll",
        objURL: "https://wompatuck-prints.s3.us-west-1.amazonaws.com/render/ToolRollOBJ.obj",
        mtlURL: "ToolRollOBJ.mtl",
        imageBasePath: "https://wompatuck-prints.s3.us-west-1.amazonaws.com/render/",
        panels: [
          {
            id: "outer",
            label: "Outer Panel",
            svgPath: "ToolRollOuter.svg",
            svgWidth: 600,
            svgHeight: 300,
            objPart: "Pattern_Outer",
            textureOffset: { x: 0.5, y: 0.5 },
            textureRepeat: { x: 1.0, y: 1.0 }
          }
        ],
        bodyMaterialMap: {
          "Pattern_Pockets": { type: "color", color: 0x000000 },
          "Pattern_Straps": { type: "color", color: 0x808080 }
        }
      }
    };

    // Get the selected bag config from URL parameter (default: feedbag)
    const urlParams = new URLSearchParams(window.location.search);
    const selectedConfigKey = urlParams.get('config') || 'feedbag';
    const CURRENT_BAG_CONFIG = BAG_CONFIGS[selectedConfigKey] || BAG_CONFIGS.feedbag;

    console.log('Selected bag configuration:', selectedConfigKey, CURRENT_BAG_CONFIG);

    // Extract configuration values for backward compatibility
    const BODY_MATERIAL_MAP = CURRENT_BAG_CONFIG.bodyMaterialMap;
    const objURL = CURRENT_BAG_CONFIG.objURL;
    const mtlURL = CURRENT_BAG_CONFIG.mtlURL;
    const imageBasePath = CURRENT_BAG_CONFIG.imageBasePath;

    // Build texture offsets and repeats from panel configs
    const TEXTURE_OFFSETS = {};
    const TEXTURE_REPEAT = {};
    CURRENT_BAG_CONFIG.panels.forEach(panel => {
      TEXTURE_OFFSETS[panel.id] = panel.textureOffset;
      TEXTURE_REPEAT[panel.id] = panel.textureRepeat;
    });

    // ═══════════════════════════════════════════════════════════════

    // ═══════════════════════════════════════════════════════════════
    // 2D FABRIC POSITIONING CANVAS
    // ═══════════════════════════════════════════════════════════════
    const fabricCanvas = document.getElementById('fabric-canvas');
    const fabricCtx = fabricCanvas.getContext('2d');

    // Build fabric panels dynamically from the current bag configuration
    const fabricPanels = {};
    CURRENT_BAG_CONFIG.panels.forEach(panelConfig => {
      fabricPanels[panelConfig.id] = {
        image: null,
        x: 0,
        y: 0,
        scale: 1,
        svgPath: panelConfig.svgPath,
        svgWidth: panelConfig.svgWidth,
        svgHeight: panelConfig.svgHeight,
        clipPath: null,
        outlinePath: null,
        displayScale: 1,
        displayOffsetX: 0,
        displayOffsetY: 0,
        label: `Current Panel: ${panelConfig.label}`,
        objPart: panelConfig.objPart  // Store the 3D model part name
      };
    });

    let currentPanel = CURRENT_BAG_CONFIG.panels[0].id; // Start with the first panel
    let isDragging = false;
    let dragStartX = 0;
    let dragStartY = 0;
    let lastX = 0;
    let lastY = 0;
    let canvasContainerWidth = 0;
    let canvasContainerHeight = 0;
    let bagID = null; // Global bag ID variable

    var albumBucketName = "wompatuck";
    var bucketRegion = "us-west-1";
    var IdentityPoolId = "us-west-1:a0541646-8d27-460f-91d9-dee5971fd529";

    // API Configuration for S3 uploads
    var S3_API_URL = "https://2olvl8lo8b.execute-api.us-west-1.amazonaws.com/prod";
    var s3 = new S3API(S3_API_URL);

    // Expose to global scope for sidebar.js and other external scripts
    window.fabricPanels = fabricPanels;
    window.currentPanel = currentPanel;


    function setBagID(){
      // First Check if there is a bagID in the URL
      const urlParams = new URLSearchParams(window.location.search);
      const urlBagID = urlParams.get('bagid') || urlParams.get('bagID');

      if (urlBagID) {
        // Load existing bag from URL parameter
        bagID = urlBagID;
        console.log("Loading existing Bag ID from URL:", bagID);

        // Try to load the bag design from S3
        loadBagFromS3(bagID).then(() => {
          console.log("Bag design loaded successfully");
        }).catch(error => {
          console.error("Failed to load bag design:", error);
          alert("Failed to load bag design. The bag ID may not exist or the images may not be accessible.");
        });
      } else {
        // Create a new Bag ID
        const currDate = new Date();
        bagID = "";
        bagID += currDate.getFullYear();
        bagID += currDate.getMonth() + 1;
        bagID += currDate.getDate();
        bagID += makeId(5);
        console.log("Created new Bag ID:", bagID);
      }

      // Report the Bag ID number
      console.log("Bag ID: " + bagID);
      console.log("Bag ID Setting: " + bagID);
      localStorage.setItem('bagID', bagID);
      window.parent.postMessage({ key: 'bagID', value: bagID }, '*');

      // Also expose to global scope for external access
      window.bagID = bagID;

      return bagID;
    }

    // Load bag design from S3 bucket using S3 API
    async function loadBagFromS3(loadBagID) {
      console.log("Loading bag design from S3 for Bag ID:", loadBagID);

      // Build image paths dynamically from panel configuration
      const imagePaths = {};
      CURRENT_BAG_CONFIG.panels.forEach(panelConfig => {
        imagePaths[panelConfig.id] = `orders/${loadBagID}/${loadBagID}_${panelConfig.id}panel.png`;
      });

      console.log("Image paths:", imagePaths);

      const loadPromises = [];

      // Load each panel image using S3 API
      for (const [panelName, imagePath] of Object.entries(imagePaths)) {
        console.log(`Loading ${panelName} from S3 key:`, imagePath);

        const loadPromise = new Promise((resolve, reject) => {
          // Use S3 API getObject to fetch the image
          s3.getObject({ Key: imagePath }, (err, data) => {
            if (err) {
              console.error(`Failed to get ${panelName} from S3:`, err);
              reject(err);
              return;
            }

            console.log(`${panelName} blob received from S3`);

            // Convert blob to image
            const blob = data.Body;
            const objectUrl = URL.createObjectURL(blob);

            const img = new Image();

            img.onload = function() {
              console.log(`${panelName} image loaded successfully`);
              console.log(`Image dimensions: ${img.width}x${img.height}`);

              // Clean up the object URL
              URL.revokeObjectURL(objectUrl);

              // Get the panel configuration
              const panel = fabricPanels[panelName];
              if (!panel) {
                console.error(`Panel not found: ${panelName}`);
                reject(new Error(`Panel not found: ${panelName}`));
                return;
              }

              // Set the image
              panel.image = img;

              // Scale the image to fill the entire canvas (cover mode)
              const imageAspect = img.width / img.height;
              const canvasAspect = panel.svgWidth / panel.svgHeight;

              if (imageAspect > canvasAspect) {
                // Image is wider - fit to height (fill vertically)
                panel.scale = panel.svgHeight / img.height;
              } else {
                // Image is taller - fit to width (fill horizontally)
                panel.scale = panel.svgWidth / img.width;
              }

              // Center the image
              panel.x = (panel.svgWidth - img.width * panel.scale) / 2;
              panel.y = (panel.svgHeight - img.height * panel.scale) / 2;

              console.log(`Applied ${panelName} to panel:`, {
                scale: panel.scale,
                x: panel.x,
                y: panel.y
              });

              resolve();
            };

            img.onerror = function(error) {
              console.error(`Failed to load ${panelName} image from blob`);
              console.error("Error:", error);
              URL.revokeObjectURL(objectUrl);
              reject(new Error(`Failed to load ${panelName} image`));
            };

            img.src = objectUrl;
          });
        });

        loadPromises.push(loadPromise);
      }

      // Wait for all images to load
      try {
        await Promise.all(loadPromises);
        console.log("All bag images loaded successfully");

        // Re-render the 2D canvas
        if (window.render2DCanvas) {
          window.render2DCanvas();
          console.log("2D canvas re-rendered with loaded images");
        }

        return true;
      } catch (error) {
        console.error("Failed to load some bag images:", error);
        throw error;
      }
    }

    function makeId(length) {
      let result = '';
      // const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      const charactersLength = characters.length;
      let counter = 0;
      while (counter < length) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
        counter += 1;
      }
      return result;
    }
    

    // Initialize UI based on bag configuration
    function initBagUI() {
      // Update page title
      const titleElement = document.getElementById('bag-title');
      if (titleElement) {
        titleElement.textContent = `Design Your ${CURRENT_BAG_CONFIG.name}`;
      }

      // Generate panel toggle buttons dynamically
      const toggleButtonsContainer = document.getElementById('panel-toggle-buttons');
      if (toggleButtonsContainer) {
        toggleButtonsContainer.innerHTML = '';

        CURRENT_BAG_CONFIG.panels.forEach((panelConfig, index) => {
          const button = document.createElement('button');
          button.className = 'toggle-btn' + (index === 0 ? ' active' : '');
          button.dataset.panel = panelConfig.id;
          button.textContent = panelConfig.label;
          toggleButtonsContainer.appendChild(button);
        });
      }
    }

    // Initialize 2D canvas
    function init2DCanvas() {
      // Initialize UI
      initBagUI();

      // Get canvas container dimensions
      const canvasContainer = document.getElementById('canvas-container');
      canvasContainerWidth = canvasContainer.clientWidth;
      canvasContainerHeight = canvasContainer.clientHeight;

      // Calculate display scaling for each panel to fit in container with padding
      const padding = 40;
      for (const [key, panel] of Object.entries(fabricPanels)) {
        const scaleX = (canvasContainerWidth - padding * 2) / panel.svgWidth;
        const scaleY = (canvasContainerHeight - padding * 2) / panel.svgHeight;
        panel.displayScale = Math.min(scaleX, scaleY, 1); // Don't scale up, only down

        // Center the canvas
        const displayWidth = panel.svgWidth * panel.displayScale;
        const displayHeight = panel.svgHeight * panel.displayScale;
        panel.displayOffsetX = (canvasContainerWidth - displayWidth) / 2;
        panel.displayOffsetY = (canvasContainerHeight - displayHeight) / 2;
      }

      // Set Bag ID
      setBagID();
      // Set initial canvas size
      updateCanvasSize();

      // Load SVG clip paths for all panels
      for (const [key, panel] of Object.entries(fabricPanels)) {
        loadSVGClipPath(key);
      }

      // Setup event listeners
      document.getElementById('fabric-img-input').addEventListener('change', handleFabricImageUpload);
      document.getElementById('generate-btn').addEventListener('click', generatePreview);

      // Add to Cart button listener
      const addToCartBtn = document.getElementById('add-to-cart-btn');
      if (addToCartBtn) {
        addToCartBtn.addEventListener('click', () => {
          // Scroll smoothly to the top of the page
          window.scrollTo({
            top: 0,
            behavior: 'smooth'
          });
        });
      }

      // Load bag button listener
      const loadBagBtn = document.getElementById('load-bag-btn');
      const loadBagInput = document.getElementById('load-bag-input');

      if (loadBagBtn && loadBagInput) {
        loadBagBtn.addEventListener('click', async () => {
          const inputBagID = loadBagInput.value.trim();

          if (!inputBagID) {
            alert('Please enter a Bag ID');
            return;
          }

          console.log('Loading bag from input:', inputBagID);

          // Disable button and show loading state
          loadBagBtn.disabled = true;
          loadBagBtn.textContent = 'Loading...';

          try {
            // Update the global bagID
            bagID = inputBagID;
            window.bagID = inputBagID;
            localStorage.setItem('bagID', inputBagID);

            // Load the bag from S3
            await loadBagFromS3(inputBagID);

            // Update the bag ID display if it exists
            const bagIdDisplay = document.getElementById('bag-id-display');
            const bagIdValue = document.getElementById('bag-id-value');
            if (bagIdDisplay && bagIdValue) {
              bagIdValue.textContent = inputBagID;
              bagIdDisplay.style.display = 'block';
            }

            alert(`Bag "${inputBagID}" loaded successfully!`);
          } catch (error) {
            console.error('Failed to load bag:', error);
            alert(`Failed to load bag "${inputBagID}". The bag may not exist or the images may not be accessible.`);
          } finally {
            // Re-enable button and restore text
            loadBagBtn.disabled = false;
            loadBagBtn.textContent = 'Load';
          }
        });

        // Also allow Enter key to trigger load
        loadBagInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            loadBagBtn.click();
          }
        });
      }

      // Toggle button listeners
      const toggleButtons = document.querySelectorAll('.toggle-btn');
      toggleButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          const panelName = btn.dataset.panel;
          switchToPanel(panelName);
        });
      });

      fabricCanvas.addEventListener('mousedown', onCanvasMouseDown);
      fabricCanvas.addEventListener('mousemove', onCanvasMouseMove);
      fabricCanvas.addEventListener('mouseup', onCanvasMouseUp);
      fabricCanvas.addEventListener('mouseleave', onCanvasMouseUp);
      fabricCanvas.addEventListener('wheel', onCanvasWheel, { passive: false });

      // Handle window resize
      window.addEventListener('resize', handleResize);

      render2DCanvas();
    }

    function handleResize() {
      const canvasContainer = document.getElementById('canvas-container');
      canvasContainerWidth = canvasContainer.clientWidth;
      canvasContainerHeight = canvasContainer.clientHeight;

      // Recalculate display scaling for each panel
      const padding = 40;
      for (const [key, panel] of Object.entries(fabricPanels)) {
        const scaleX = (canvasContainerWidth - padding * 2) / panel.svgWidth;
        const scaleY = (canvasContainerHeight - padding * 2) / panel.svgHeight;
        panel.displayScale = Math.min(scaleX, scaleY, 1);

        const displayWidth = panel.svgWidth * panel.displayScale;
        const displayHeight = panel.svgHeight * panel.displayScale;
        panel.displayOffsetX = (canvasContainerWidth - displayWidth) / 2;
        panel.displayOffsetY = (canvasContainerHeight - displayHeight) / 2;
      }

      updateCanvasSize();
      render2DCanvas();
    }

    function updateCanvasSize() {
      const panel = fabricPanels[currentPanel];
      const displayWidth = panel.svgWidth * panel.displayScale;
      const displayHeight = panel.svgHeight * panel.displayScale;

      fabricCanvas.width = displayWidth;
      fabricCanvas.height = displayHeight;

      // Center the canvas using CSS transform (already set in styles)
      // Remove any inline positioning that would override CSS
      fabricCanvas.style.left = '50%';
      fabricCanvas.style.top = '50%';
      fabricCanvas.style.transform = 'translate(-50%, -50%)';
    }

    function switchToPanel(panelName) {
      currentPanel = panelName;
      window.currentPanel = panelName; // Update global reference

      // Update toggle buttons
      document.querySelectorAll('.toggle-btn').forEach(btn => {
        if (btn.dataset.panel === panelName) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });

      // Update panel name
      const panel = fabricPanels[panelName];
      //document.getElementById('current-panel-name').textContent = panel.label;

      // Update canvas size
      updateCanvasSize();

      // Re-render
      render2DCanvas();
    }

    function loadSVGClipPath(panelName) {
      const panel = fabricPanels[panelName];
      const img = new Image();
      img.onload = () => {
        panel.clipPath = img;

        // Create an outlined version of the SVG for preview
        createOutlineFromMask(img, panel.svgWidth, panel.svgHeight).then(outlineImg => {
          panel.outlinePath = outlineImg;
          render2DCanvas();
        });
      };
      img.src = panel.svgPath;
    }

    // Create an outline stroke from a filled SVG mask
    function createOutlineFromMask(maskImg, width, height) {
      return new Promise((resolve) => {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = width;
        tempCanvas.height = height;
        const tempCtx = tempCanvas.getContext('2d');

        // Draw the mask
        tempCtx.drawImage(maskImg, 0, 0, width, height);

        // Get image data to detect edges
        const imageData = tempCtx.getImageData(0, 0, width, height);
        const data = imageData.data;

        // Create a new canvas for the outline
        const outlineCanvas = document.createElement('canvas');
        outlineCanvas.width = width;
        outlineCanvas.height = height;
        const outlineCtx = outlineCanvas.getContext('2d');

        // Draw edges by detecting alpha changes
        outlineCtx.strokeStyle = '#507CBC';
        outlineCtx.lineWidth = 2;
        outlineCtx.beginPath();

        // Simple edge detection - look for alpha transitions
        for (let y = 1; y < height - 1; y++) {
          for (let x = 1; x < width - 1; x++) {
            const idx = (y * width + x) * 4;
            const alpha = data[idx + 3];

            // Check if this is an edge pixel (alpha changes from neighbor)
            const leftAlpha = data[(y * width + (x - 1)) * 4 + 3];
            const rightAlpha = data[(y * width + (x + 1)) * 4 + 3];
            const topAlpha = data[((y - 1) * width + x) * 4 + 3];
            const bottomAlpha = data[((y + 1) * width + x) * 4 + 3];

            if (alpha > 128 && (leftAlpha < 128 || rightAlpha < 128 || topAlpha < 128 || bottomAlpha < 128)) {
              outlineCtx.fillStyle = '#507CBC';
              outlineCtx.fillRect(x, y, 1, 1);
            }
          }
        }

        // Convert to image
        const outlineImg = new Image();
        outlineImg.onload = () => resolve(outlineImg);
        outlineImg.src = outlineCanvas.toDataURL();
      });
    }

    function handleFabricImageUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          const panel = fabricPanels[currentPanel];
          panel.image = img;

          // Scale the image to fill the entire canvas (cover mode)
          const imageAspect = img.width / img.height;
          const canvasAspect = panel.svgWidth / panel.svgHeight;

          if (imageAspect > canvasAspect) {
            // Image is wider - fit to height (fill vertically)
            panel.scale = panel.svgHeight / img.height;
          } else {
            // Image is taller - fit to width (fill horizontally)
            panel.scale = panel.svgWidth / img.width;
          }

          // Center the image
          panel.x = (panel.svgWidth - img.width * panel.scale) / 2;
          panel.y = (panel.svgHeight - img.height * panel.scale) / 2;

          render2DCanvas();
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);

      // Reset the file input value to allow re-uploading the same file
      event.target.value = '';
    }

    function onCanvasMouseDown(e) {
      const panel = fabricPanels[currentPanel];
      if (!panel.image) return;

      isDragging = true;
      const rect = fabricCanvas.getBoundingClientRect();
      dragStartX = (e.clientX - rect.left) / panel.displayScale;
      dragStartY = (e.clientY - rect.top) / panel.displayScale;
      lastX = panel.x;
      lastY = panel.y;
    }

    function onCanvasMouseMove(e) {
      if (!isDragging) return;

      const rect = fabricCanvas.getBoundingClientRect();
      const currentX = (e.clientX - rect.left) / fabricPanels[currentPanel].displayScale;
      const currentY = (e.clientY - rect.top) / fabricPanels[currentPanel].displayScale;

      const panel = fabricPanels[currentPanel];
      panel.x = lastX + (currentX - dragStartX);
      panel.y = lastY + (currentY - dragStartY);

      render2DCanvas();
    }

    function onCanvasMouseUp() {
      isDragging = false;
    }

    function onCanvasWheel(e) {
      e.preventDefault();

      const panel = fabricPanels[currentPanel];
      if (!panel.image) return;

      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      const newScale = Math.max(0.1, Math.min(5, panel.scale * delta));

      // Zoom towards mouse position (accounting for display scale)
      const rect = fabricCanvas.getBoundingClientRect();
      const mouseX = (e.clientX - rect.left) / panel.displayScale;
      const mouseY = (e.clientY - rect.top) / panel.displayScale;

      const scaleChange = newScale / panel.scale;
      panel.x = mouseX - (mouseX - panel.x) * scaleChange;
      panel.y = mouseY - (mouseY - panel.y) * scaleChange;
      panel.scale = newScale;

      render2DCanvas();
    }

    function render2DCanvas() {
      const panel = fabricPanels[currentPanel];

      fabricCtx.clearRect(0, 0, fabricCanvas.width, fabricCanvas.height);

      // Scale context to fit display
      fabricCtx.save();
      fabricCtx.scale(panel.displayScale, panel.displayScale);

      // Draw checkerboard background
      drawCheckerboard(fabricCtx, panel.svgWidth, panel.svgHeight);

      if (panel.image) {
        const imgWidth = panel.image.width * panel.scale;
        const imgHeight = panel.image.height * panel.scale;

        // Layer 1: Draw the full image at 25% opacity
        fabricCtx.globalAlpha = 1.0;
        fabricCtx.drawImage(panel.image, panel.x, panel.y, imgWidth, imgHeight);
        fabricCtx.globalAlpha = 1.0;

        // Layer 2: Draw the cropped image at 100% opacity (if we have a clipping mask)
        if (panel.clipPath) {
          // Save current state
          fabricCtx.save();

          // Create clipping region from the SVG mask
          fabricCtx.globalCompositeOperation = 'source-over';

          // Draw image again
          fabricCtx.drawImage(panel.image, panel.x, panel.y, imgWidth, imgHeight);

          // Apply mask to show only the clipped portion
          fabricCtx.globalCompositeOperation = 'destination-in';
          fabricCtx.drawImage(panel.clipPath, 0, 0, panel.svgWidth, panel.svgHeight);

          // Restore composite operation
          fabricCtx.globalCompositeOperation = 'source-over';

          fabricCtx.restore();
        }
      }

      // Layer 3: Draw the SVG outline stroke (no fill) on top
      if (panel.outlinePath) {
        fabricCtx.save();
        fabricCtx.globalAlpha = 1.0;
        fabricCtx.drawImage(panel.outlinePath, 0, 0, panel.svgWidth, panel.svgHeight);
        fabricCtx.restore();
      }

      fabricCtx.restore();
    }

    // Expose render2DCanvas to global scope for sidebar.js
    window.render2DCanvas = render2DCanvas;

    function drawCheckerboard(ctx, width, height) {
      const squareSize = 20;
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, width, height);

      ctx.fillStyle = '#e0e0e0';
      for (let y = 0; y < height; y += squareSize) {
        for (let x = 0; x < width; x += squareSize) {
          if ((x / squareSize + y / squareSize) % 2 === 0) {
            ctx.fillRect(x, y, squareSize, squareSize);
          }
        }
      }
    }

    // Generate textures from the positioned images
    async function generateFabricTextures() {
      const textures = {};

      // Resolution multiplier for higher quality textures (2x, 3x, or 4x)
      const TEXTURE_RESOLUTION_SCALE = 4;

      for (const [panelName, panel] of Object.entries(fabricPanels)) {
        if (!panel.image || !panel.clipPath) {
          console.log(`Skipping ${panelName}: image=${!!panel.image}, clipPath=${!!panel.clipPath}`);
          continue;
        }

        console.log(`Generating texture for ${panelName}:`, {
          svgSize: `${panel.svgWidth}x${panel.svgHeight}`,
          outputSize: `${panel.svgWidth * TEXTURE_RESOLUTION_SCALE}x${panel.svgHeight * TEXTURE_RESOLUTION_SCALE}`,
          imageSize: `${panel.image.width}x${panel.image.height}`,
          position: `x=${panel.x}, y=${panel.y}`,
          scale: panel.scale
        });

        // Create an offscreen canvas for this panel at higher resolution
        const offCanvas = document.createElement('canvas');
        offCanvas.width = panel.svgWidth * TEXTURE_RESOLUTION_SCALE;
        offCanvas.height = panel.svgHeight * TEXTURE_RESOLUTION_SCALE;
        const offCtx = offCanvas.getContext('2d');

        // Scale the context to render at higher resolution
        offCtx.scale(TEXTURE_RESOLUTION_SCALE, TEXTURE_RESOLUTION_SCALE);

        // Draw the positioned image
        const imgWidth = panel.image.width * panel.scale;
        const imgHeight = panel.image.height * panel.scale;
        offCtx.drawImage(panel.image, panel.x, panel.y, imgWidth, imgHeight);

        // Apply the SVG mask
        offCtx.globalCompositeOperation = 'destination-in';
        offCtx.drawImage(panel.clipPath, 0, 0, panel.svgWidth, panel.svgHeight);

        // Convert to texture with high quality
        textures[panelName] = offCanvas.toDataURL('image/png');
        console.log(`Generated ${panelName} texture at ${offCanvas.width}x${offCanvas.height}, data URL length: ${textures[panelName].length}`);
      }

      return textures;
    }

    // Generate raw (uncropped) textures from the positioned images
    async function generateRawTextures() {
      const textures = {};

      // Resolution multiplier for higher quality textures (same as cropped)
      const TEXTURE_RESOLUTION_SCALE = 4;

      for (const [panelName, panel] of Object.entries(fabricPanels)) {
        if (!panel.image) {
          console.log(`Skipping raw ${panelName}: no image`);
          continue;
        }

        console.log(`Generating raw texture for ${panelName}:`, {
          svgSize: `${panel.svgWidth}x${panel.svgHeight}`,
          outputSize: `${panel.svgWidth * TEXTURE_RESOLUTION_SCALE}x${panel.svgHeight * TEXTURE_RESOLUTION_SCALE}`,
          imageSize: `${panel.image.width}x${panel.image.height}`,
          position: `x=${panel.x}, y=${panel.y}`,
          scale: panel.scale
        });

        // Create an offscreen canvas for this panel at higher resolution
        const offCanvas = document.createElement('canvas');
        offCanvas.width = panel.svgWidth * TEXTURE_RESOLUTION_SCALE;
        offCanvas.height = panel.svgHeight * TEXTURE_RESOLUTION_SCALE;
        const offCtx = offCanvas.getContext('2d');

        // Scale the context to render at higher resolution
        offCtx.scale(TEXTURE_RESOLUTION_SCALE, TEXTURE_RESOLUTION_SCALE);

        // Draw white background
        offCtx.fillStyle = '#ffffff';
        offCtx.fillRect(0, 0, panel.svgWidth, panel.svgHeight);

        // Draw the positioned image WITHOUT clipping
        const imgWidth = panel.image.width * panel.scale;
        const imgHeight = panel.image.height * panel.scale;
        offCtx.drawImage(panel.image, panel.x, panel.y, imgWidth, imgHeight);

        // Convert to texture with high quality
        textures[panelName] = offCanvas.toDataURL('image/png');
        console.log(`Generated raw ${panelName} texture at ${offCanvas.width}x${offCanvas.height}, data URL length: ${textures[panelName].length}`);
      }

      return textures;
    }

    // Download the cropped texture images
    function downloadCroppedImages(fabricTextures) {
      let delay = 0;
      for (const [panelName, dataUrl] of Object.entries(fabricTextures)) {
        if (!dataUrl) continue;

        // Add a small delay between downloads to prevent conflicts
        setTimeout(() => {
          // Create a temporary link element
          const link = document.createElement('a');
          link.download = `${panelName}_cropped_texture.png`;
          link.href = dataUrl;

          // Trigger download
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);

          console.log(`Downloaded ${panelName} texture`);
        }, delay);

        delay += 100; // 100ms delay between downloads
      }
    }

    
async function savetoS3(fabricTextures, rawTextures){
  console.log("Saving Pattern Images to S3...");

  if (!fabricTextures) {
    console.error("No fabric textures provided to savetoS3");
    return;
  }

  // Build S3 key mappings dynamically from panel configuration
  const s3KeyMap = {};
  const s3KeyMapRaw = {};

  CURRENT_BAG_CONFIG.panels.forEach(panelConfig => {
    s3KeyMap[panelConfig.id] = `orders/${bagID}/${bagID}_${panelConfig.id}panel.png`;
    s3KeyMapRaw[panelConfig.id] = `orders/${bagID}/${bagID}_${panelConfig.id}panel_raw.png`;
  });

  console.log("S3 upload paths (cropped):", s3KeyMap);
  console.log("S3 upload paths (raw):", s3KeyMapRaw);

  // Helper function to convert data URL to Blob
  function dataURLtoBlob(dataURL) {
    const arr = dataURL.split(',');
    const mime = arr[0].match(/:(.*?);/)[1];
    const bstr = atob(arr[1]);
    let n = bstr.length;
    const u8arr = new Uint8Array(n);
    while (n--) {
      u8arr[n] = bstr.charCodeAt(n);
    }
    return new Blob([u8arr], { type: mime });
  }

  // Upload each panel (cropped and raw)
  const uploadPromises = [];

  // Upload cropped images
  for (const [panelName, dataUrl] of Object.entries(fabricTextures)) {
    if (!dataUrl) {
      console.log(`Skipping cropped ${panelName}: no data URL`);
      continue;
    }

    const s3Key = s3KeyMap[panelName];
    if (!s3Key) {
      console.log(`Skipping cropped ${panelName}: no S3 key mapping`);
      continue;
    }

    console.log(`Uploading cropped ${panelName} to ${s3Key}...`);

    // Convert data URL to Blob
    const blob = dataURLtoBlob(dataUrl);

    // Create upload promise
    const uploadPromise = new Promise((resolve, reject) => {
      const params = {
        Key: s3Key,
        Body: blob,
        ContentType: 'image/png'
      };

      s3.upload(params)
        .on('httpUploadProgress', progress => {
          const percentComplete = Math.round((progress.loaded / progress.total) * 100);
          console.log(`Upload progress for cropped ${panelName}: ${percentComplete}%`);
        })
        .send((err, res) => {
          if (err) {
            console.error(`Error uploading cropped ${panelName}:`, err);
            reject(err);
          } else {
            console.log(`Successfully uploaded cropped ${panelName} to S3:`, res.key);
            resolve(res);
          }
        });
    });

    uploadPromises.push(uploadPromise);
  }

  // Upload raw images if provided
  if (rawTextures) {
    for (const [panelName, dataUrl] of Object.entries(rawTextures)) {
      if (!dataUrl) {
        console.log(`Skipping raw ${panelName}: no data URL`);
        continue;
      }

      const s3Key = s3KeyMapRaw[panelName];
      if (!s3Key) {
        console.log(`Skipping raw ${panelName}: no S3 key mapping`);
        continue;
      }

      console.log(`Uploading raw ${panelName} to ${s3Key}...`);

      // Convert data URL to Blob
      const blob = dataURLtoBlob(dataUrl);

      // Create upload promise
      const uploadPromise = new Promise((resolve, reject) => {
        const params = {
          Key: s3Key,
          Body: blob,
          ContentType: 'image/png'
        };

        s3.upload(params)
          .on('httpUploadProgress', progress => {
            const percentComplete = Math.round((progress.loaded / progress.total) * 100);
            console.log(`Upload progress for raw ${panelName}: ${percentComplete}%`);
          })
          .send((err, res) => {
            if (err) {
              console.error(`Error uploading raw ${panelName}:`, err);
              reject(err);
            } else {
              console.log(`Successfully uploaded raw ${panelName} to S3:`, res.key);
              resolve(res);
            }
          });
      });

      uploadPromises.push(uploadPromise);
    }
  }

  // Wait for all uploads to complete
  try {
    const results = await Promise.all(uploadPromises);
    console.log("All images uploaded successfully!");
    return results;
  } catch (error) {
    console.error("Error uploading images to S3:", error);
    throw error;
  }
}


    // ═══════════════════════════════════════════════════════════════
    // 3D MODEL RENDERING
    // ═══════════════════════════════════════════════════════════════
    let camera, scene, renderer, controls;
    let objMesh = null;
    let defaultTexture = null;
    let currentModel = null; // Store reference to current 3D model
    let mtlMaterials = null; // Store materials loaded from MTL file

    init2DCanvas();
    init3D();
    loadModelWithDefaultTexture();

    function init3D() {
      const canvas = document.getElementById('c');

      const rightPanel = document.getElementById('right-panel');
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(rightPanel.clientWidth, rightPanel.clientHeight);

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f0f0);

      camera = new THREE.PerspectiveCamera(45, rightPanel.clientWidth / rightPanel.clientHeight, 0.1, 1000);
      camera.position.set(0, 0, 5);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      // Lighting setup
      scene.add(new THREE.AmbientLight(0xffffff, 0.4));

      // Top directional light
      const topLight = new THREE.DirectionalLight(0xffffff, 0.3);
      topLight.position.set(0, 10, 0);
      scene.add(topLight);

      // Bottom directional light (illuminates the bottom surface)
      const bottomLight = new THREE.DirectionalLight(0xffffff, 0.2);
      bottomLight.position.set(0, -10, 0);
      scene.add(bottomLight);

      // Front light
      const frontLight = new THREE.DirectionalLight(0xffffff, 0.3);
      frontLight.position.set(0, 0, 10);
      scene.add(frontLight);

      // Back light
      const backLight = new THREE.DirectionalLight(0xffffff, 0.2);
      backLight.position.set(0, 0, -10);
      scene.add(backLight);

      // Side lights for even coverage
      const leftLight = new THREE.DirectionalLight(0xffffff, 0.2);
      leftLight.position.set(-10, 0, 0);
      scene.add(leftLight);

      const rightLight = new THREE.DirectionalLight(0xffffff, 0.2);
      rightLight.position.set(10, 0, 0);
      scene.add(rightLight);

      window.addEventListener('resize', () => {
        const rightPanel = document.getElementById('right-panel');
        camera.aspect = rightPanel.clientWidth / rightPanel.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(rightPanel.clientWidth, rightPanel.clientHeight);
      });

      animate3D();
    }

    function loadModelWithDefaultTexture() {
        const mtlLoader = new MTLLoader();
        const objLoader = new OBJLoader();
        const texLoader = new THREE.TextureLoader();

        // First, load the MTL file to get default materials
        mtlLoader.load(
          mtlURL,
          (materials) => {
            console.log('MTL materials loaded:', materials);
            mtlMaterials = materials;
            materials.preload();

            // Pre-load all unique textures from BODY_MATERIAL_MAP
            const textureCache = {};
            const texturesToLoad = new Set();

            Object.values(BODY_MATERIAL_MAP).forEach(config => {
              if (config.type === "texture" && config.image) {
                texturesToLoad.add(config.image);
              }
            });

            const texturePromises = Array.from(texturesToLoad).map(imageName => {
              return new Promise((resolve, reject) => {
                const imageUrl = imageName.startsWith('http') ? imageName : imageBasePath + imageName;
                texLoader.load(
                  imageUrl,
                  texture => {
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.wrapS  = THREE.RepeatWrapping;
                    texture.repeat.set(1, 1);
                    texture.flipY = true;
                    textureCache[imageName] = texture;
                    resolve();
                  },
                  undefined,
                  error => {
                    console.error(`Failed to load texture: ${imageName}`, error);
                    resolve(); // Continue even if texture fails
                  }
                );
              });
            });

            Promise.all(texturePromises).then(() => {
              objLoader.load(objURL, obj => {
                obj.traverse(child => {
                  if (child.isMesh) {
                    const config = BODY_MATERIAL_MAP[child.name];

                    if (config) {
                      // User has explicitly configured this mesh
                      if (config.type === "texture" && config.image) {
                        const texture = textureCache[config.image];
                        if (texture) {
                          child.material = new THREE.MeshStandardMaterial({ map: texture });
                        } else {
                          child.material = new THREE.MeshStandardMaterial({ color: 0x808080 });
                        }
                      } else if (config.type === "color") {
                        child.material = new THREE.MeshStandardMaterial({ color: config.color });
                      }
                    } else {
                      // Not explicitly configured - try to use MTL material
                      if (child.material && child.material.name && mtlMaterials.materials[child.material.name]) {
                        // Use the material from MTL file
                        const mtlMaterial = mtlMaterials.materials[child.material.name];
                        child.material = mtlMaterial;
                        console.log(`Applied MTL material "${child.material.name}" to ${child.name}`);
                      } else {
                        // No MTL material found - default to black
                        child.material = new THREE.MeshStandardMaterial({ color: 0x000000 });
                        console.log(`No material found for ${child.name}, defaulting to black`);
                      }
                    }
                  }
                });

                // Center camera on model
                const bbox = new THREE.Box3().setFromObject(obj);
                const center = bbox.getCenter(new THREE.Vector3());
                const size = bbox.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const fitDist = maxDim * 1.5;

                camera.position.set(center.x, center.y, center.z + fitDist);
                camera.lookAt(center);
                controls.target.copy(center);
                controls.update();

                scene.add(obj);
              });
            });
          },
          undefined,
          (error) => {
            console.error('Error loading MTL file:', error);
            // Fallback: load OBJ without MTL materials
            loadOBJWithoutMTL();
          }
        );

        // Fallback function to load OBJ without MTL
        function loadOBJWithoutMTL() {
          const texLoader = new THREE.TextureLoader();
          const textureCache = {};
          const texturesToLoad = new Set();

          Object.values(BODY_MATERIAL_MAP).forEach(config => {
            if (config.type === "texture" && config.image) {
              texturesToLoad.add(config.image);
            }
          });

          const texturePromises = Array.from(texturesToLoad).map(imageName => {
            return new Promise((resolve, reject) => {
              const imageUrl = imageName.startsWith('http') ? imageName : imageBasePath + imageName;
              texLoader.load(
                imageUrl,
                texture => {
                  texture.wrapT = THREE.RepeatWrapping;
                  texture.wrapS  = THREE.RepeatWrapping;
                  texture.repeat.set(1, 1);
                  texture.flipY = true;
                  textureCache[imageName] = texture;
                  resolve();
                },
                undefined,
                error => {
                  console.error(`Failed to load texture: ${imageName}`, error);
                  resolve();
                }
              );
            });
          });

          Promise.all(texturePromises).then(() => {
            objLoader.load(objURL, obj => {
              obj.traverse(child => {
                if (child.isMesh) {
                  const config = BODY_MATERIAL_MAP[child.name];

                  if (config) {
                    if (config.type === "texture" && config.image) {
                      const texture = textureCache[config.image];
                      if (texture) {
                        child.material = new THREE.MeshStandardMaterial({ map: texture });
                      } else {
                        child.material = new THREE.MeshStandardMaterial({ color: 0x808080 });
                      }
                    } else if (config.type === "color") {
                      child.material = new THREE.MeshStandardMaterial({ color: config.color });
                    }
                  } else {
                    child.material = new THREE.MeshStandardMaterial({ color: 0x000000 });
                  }
                }
              });

              const bbox = new THREE.Box3().setFromObject(obj);
              const center = bbox.getCenter(new THREE.Vector3());
              const size = bbox.getSize(new THREE.Vector3());
              const maxDim = Math.max(size.x, size.y, size.z);
              const fitDist = maxDim * 1.5;

              camera.position.set(center.x, center.y, center.z + fitDist);
              camera.lookAt(center);
              controls.target.copy(center);
              controls.update();

              scene.add(obj);
            });
          });
        }

      // const loader = new OBJLoader();
      // const texLoader = new THREE.TextureLoader();

      // texLoader.load(textureURL, texture => {
      //   defaultTexture = texture;
      //   texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      //   texture.repeat.set(1, 1);
      //   texture.flipY = false;

      //   loader.load(objURL, obj => {
      //     const targetParts = ["Pattern_25179", "Pattern_25178"];

      //     obj.traverse(child => {
      //       console.log('Part:', child.name);
      //       if (child.isMesh) {
      //         if (targetParts.includes(child.name)) {
      //           child.material = new THREE.MeshStandardMaterial({ map: fabricTexture });
      //         } else {
      //           child.material = new THREE.MeshStandardMaterial({ color: 0xeeeeee });
      //         }
      //       }
      //     });

          

      //     // Center camera on model
      //     const bbox = new THREE.Box3().setFromObject(obj);
      //     const center = bbox.getCenter(new THREE.Vector3());
      //     const size = bbox.getSize(new THREE.Vector3());
      //     const maxDim = Math.max(size.x, size.y, size.z);
      //     const fitDist = maxDim * 1.5;

      //     camera.position.set(center.x, center.y, center.z + fitDist);
      //     camera.lookAt(center);
      //     controls.target.copy(center);
      //     controls.update();

      //     scene.add(obj);
      //   });
      // });

      
    }

    // Generate 3D Preview with positioned fabric textures
    async function generatePreview() {
      console.log("Generating 3D Preview...");
      console.log("Posting BagID: " + bagID);
      localStorage.setItem('bagID', bagID);
      window.parent.postMessage({ key: 'bagID', value: bagID }, '*');

      // Display Bag ID
      const bagIdDisplay = document.getElementById('bag-id-display');
      const bagIdValue = document.getElementById('bag-id-value');
      if (bagIdDisplay && bagIdValue && bagID) {
        bagIdValue.textContent = bagID;
        bagIdDisplay.style.display = 'block';
      }

      // Show loading indicator
      const loadingOverlay = document.getElementById('loading-overlay');
      if (loadingOverlay) {
        loadingOverlay.classList.add('visible');
      }

      // Clear the current scene
      while(scene.children.length > 0) {
        scene.remove(scene.children[0]);
      }

      // Re-add lighting with reduced intensity for better texture visibility
      scene.add(new THREE.AmbientLight(0xffffff, 0.6));

      // Add directional lights for depth
      const topLight = new THREE.DirectionalLight(0xffffff, 0.4);
      topLight.position.set(0, 10, 0);
      scene.add(topLight);

      const frontLight = new THREE.DirectionalLight(0xffffff, 0.4);
      frontLight.position.set(0, 0, 10);
      scene.add(frontLight);

      // // Top directional light
      // const topLight = new THREE.DirectionalLight(0xffffff, 0.25);
      // topLight.position.set(0, 10, 0);
      // scene.add(topLight);

      // // Bottom directional light (illuminates the bottom surface)
      // const bottomLight = new THREE.DirectionalLight(0xffffff, 0.25);
      // bottomLight.position.set(0, -10, 0);
      // scene.add(bottomLight);

      // // Front light
      // const frontLight = new THREE.DirectionalLight(0xffffff, 0.125);
      // frontLight.position.set(0, 0, 10);
      // scene.add(frontLight);

      // // Back light
      // const backLight = new THREE.DirectionalLight(0xffffff, 0.125);
      // backLight.position.set(0, 0, -10);
      // scene.add(backLight);

      // Side lights for even coverage
      // const leftLight = new THREE.DirectionalLight(0xffffff, 0.4);
      // leftLight.position.set(-10, 0, 0);
      // scene.add(leftLight);

      // const rightLight = new THREE.DirectionalLight(0xffffff, 0.4);
      // rightLight.position.set(10, 0, 0);
      // scene.add(rightLight);

      // Generate textures from the 2D canvas
      const fabricTextures = await generateFabricTextures();
      const rawTextures = await generateRawTextures();

      // Upload both cropped and raw images to S3
      try {
        await savetoS3(fabricTextures, rawTextures);
        console.log("Fabric textures (cropped and raw) uploaded to S3 successfully");
      } catch (error) {
        console.error("Failed to upload textures to S3:", error);
        // Continue with rendering even if upload fails
      }

      // Download the cropped images for debugging
      //downloadCroppedImages(fabricTextures);

      const loader = new OBJLoader();
      const texLoader = new THREE.TextureLoader();

      // Load custom textures from the 2D canvas dynamically
      const textureCache = {};

      // Load textures for all configured panels
      CURRENT_BAG_CONFIG.panels.forEach(panelConfig => {
        if (fabricTextures[panelConfig.id]) {
          const texture = texLoader.load(fabricTextures[panelConfig.id]);

          // === WRAPPING OPTIONS ===
          texture.wrapS = THREE.ClampToEdgeWrapping;
          texture.wrapT = THREE.ClampToEdgeWrapping;

          // === REPEAT/SCALE ===
          texture.repeat.set(TEXTURE_REPEAT[panelConfig.id].x, TEXTURE_REPEAT[panelConfig.id].y);

          // === FLIP ===
          texture.flipY = true;

          // === OFFSET/POSITION ===
          texture.offset.set(TEXTURE_OFFSETS[panelConfig.id].x, TEXTURE_OFFSETS[panelConfig.id].y);

          console.log('═══════════════════════════════════════');
          console.log(`${panelConfig.label.toUpperCase()} TEXTURE (${panelConfig.objPart})`);
          console.log('═══════════════════════════════════════');
          console.log('Texture Properties:');
          console.log(`  - wrapS: ${texture.wrapS === THREE.ClampToEdgeWrapping ? 'ClampToEdgeWrapping' : texture.wrapS === THREE.RepeatWrapping ? 'RepeatWrapping' : 'MirroredRepeatWrapping'}`);
          console.log(`  - wrapT: ${texture.wrapT === THREE.ClampToEdgeWrapping ? 'ClampToEdgeWrapping' : texture.wrapT === THREE.RepeatWrapping ? 'RepeatWrapping' : 'MirroredRepeatWrapping'}`);
          console.log(`  - repeat: (${texture.repeat.x}, ${texture.repeat.y})`);
          console.log(`  - offset: (${texture.offset.x}, ${texture.offset.y})`);
          console.log(`  - rotation: ${texture.rotation} radians (${(texture.rotation * 180 / Math.PI).toFixed(1)}°)`);
          console.log(`  - center: (${texture.center.x}, ${texture.center.y})`);
          console.log(`  - flipY: ${texture.flipY}`);

          textureCache[panelConfig.id] = texture;
        }
      });

      // Load the 3D model
      loader.load(objURL, obj => {
        console.log("=== Loading 3D Model ===");
        console.log("Available textures:", Object.keys(textureCache));

        // First pass: log all mesh names
        const meshNames = [];
        obj.traverse(child => {
          if (child.isMesh) {
            meshNames.push(child.name);
          }
        });
        console.log("All mesh names in OBJ:", meshNames);

        // Build a mapping from objPart name to panel config and texture
        const objPartToPanel = {};
        const partInstanceCounts = {};
        CURRENT_BAG_CONFIG.panels.forEach(panelConfig => {
          objPartToPanel[panelConfig.objPart] = {
            config: panelConfig,
            texture: textureCache[panelConfig.id]
          };
          partInstanceCounts[panelConfig.objPart] = 0;
        });

        obj.traverse(child => {
          if (child.isMesh) {
            const config = BODY_MATERIAL_MAP[child.name];
            const panelMapping = objPartToPanel[child.name];

            // Check if this mesh corresponds to a customizable panel
            if (panelMapping) {
              partInstanceCounts[child.name]++;
              const instanceNum = partInstanceCounts[child.name];

              if (panelMapping.texture) {
                console.log(`\n✓ Applying ${panelMapping.config.label.toUpperCase()} texture to ${child.name} (instance ${instanceNum})`);

                // Log mesh geometry info
                console.log(`  Mesh Info:`);
                console.log(`    - Vertices: ${child.geometry.attributes.position.count}`);
                console.log(`    - Faces: ${child.geometry.index ? child.geometry.index.count / 3 : 'N/A'}`);
                console.log(`    - Has UV mapping: ${!!child.geometry.attributes.uv}`);
                if (child.geometry.attributes.uv) {
                  const uvArray = child.geometry.attributes.uv.array;
                  console.log(`    - UV coordinates count: ${uvArray.length / 2}`);

                  // Calculate UV min/max without spread operator (avoids stack overflow)
                  let minU = Infinity, maxU = -Infinity, minV = Infinity, maxV = -Infinity;
                  for (let i = 0; i < uvArray.length; i += 2) {
                    const u = uvArray[i];
                    const v = uvArray[i + 1];
                    if (u < minU) minU = u;
                    if (u > maxU) maxU = u;
                    if (v < minV) minV = v;
                    if (v > maxV) maxV = v;
                  }
                  console.log(`    - UV range: U[${minU.toFixed(3)}, ${maxU.toFixed(3)}], V[${minV.toFixed(3)}, ${maxV.toFixed(3)}]`);
                }

                // Calculate mesh bounds
                child.geometry.computeBoundingBox();
                const bbox = child.geometry.boundingBox;
                console.log(`    - Bounding box:`);
                console.log(`      Min: (${bbox.min.x.toFixed(2)}, ${bbox.min.y.toFixed(2)}, ${bbox.min.z.toFixed(2)})`);
                console.log(`      Max: (${bbox.max.x.toFixed(2)}, ${bbox.max.y.toFixed(2)}, ${bbox.max.z.toFixed(2)})`);
                console.log(`      Size: (${(bbox.max.x - bbox.min.x).toFixed(2)}, ${(bbox.max.y - bbox.min.y).toFixed(2)}, ${(bbox.max.z - bbox.min.z).toFixed(2)})`);

                child.material = new THREE.MeshStandardMaterial({
                  map: panelMapping.texture,
                  roughness: 0.8,
                  metalness: 0.0
                });
              } else {
                console.log(`✗ No texture available for ${child.name}`);
                child.material = new THREE.MeshStandardMaterial({ color: 0xff0000 }); // Red for debugging
              }
            } else if (config) {
              // User has explicitly configured this mesh
              if (config.type === "color") {
                child.material = new THREE.MeshStandardMaterial({ color: config.color });
              } else {
                child.material = new THREE.MeshStandardMaterial({ color: 0x808080 });
              }
            } else {
              // Not explicitly configured - try to use MTL material
              if (child.material && child.material.name && mtlMaterials && mtlMaterials.materials[child.material.name]) {
                const mtlMaterial = mtlMaterials.materials[child.material.name];
                child.material = mtlMaterial;
                console.log(`Applied MTL material "${child.material.name}" to ${child.name}`);
              } else {
                child.material = new THREE.MeshStandardMaterial({ color: 0x000000 });
                console.log(`No material found for ${child.name}, defaulting to black`);
              }
            }
          }
        });

        // Log summary of applied textures
        console.log('\n=== Texture Application Summary ===');
        Object.entries(partInstanceCounts).forEach(([partName, count]) => {
          console.log(`Found ${count} instances of ${partName}`);
        });

        // Center camera on model
        const bbox = new THREE.Box3().setFromObject(obj);
        const center = bbox.getCenter(new THREE.Vector3());
        const size = bbox.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        const fitDist = maxDim * 1.5;

        camera.position.set(center.x, center.y, center.z + fitDist);
        camera.lookAt(center);
        controls.target.copy(center);
        controls.update();

        currentModel = obj;
        scene.add(obj);

        console.log("3D Preview generated successfully!");

        // Hide loading indicator
        const loadingOverlay = document.getElementById('loading-overlay');
        if (loadingOverlay) {
          loadingOverlay.classList.remove('visible');
        }

        // Show Add to Cart button
        const addToCartBtn = document.getElementById('add-to-cart-btn');
        if (addToCartBtn) {
          addToCartBtn.style.display = 'block';
        }
      });
    }

    function animate3D() {
      requestAnimationFrame(animate3D);
      controls.update();
      renderer.render(scene, camera);
    }

    
  </script>
</body>
</html>
